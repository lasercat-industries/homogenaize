{"version":3,"file":"streaming.js","sourceRoot":"","sources":["../../src/streaming/streaming.ts"],"names":[],"mappings":"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","sourcesContent":["import { z } from 'zod';\n\nexport interface StreamingResult<T> {\n  isComplete: boolean;\n  data?: T;\n  partialData?: Partial<T>;\n  validationStatus: 'valid' | 'invalid' | 'partial';\n  errors?: Array<{ path: string; message: string }>;\n}\n\nexport interface StreamingOptions<T> {\n  messages: Array<{ role: string; content: string }>;\n  schema: z.ZodSchema<T>;\n  onChunk?: (result: StreamingResult<T>) => void;\n}\n\nexport class StreamingResponseHandler<T> {\n  private buffer: string = '';\n\n  constructor(private schema: z.ZodSchema<T>) {}\n\n  async processChunk(chunk: string): Promise<StreamingResult<T>> {\n    this.buffer += chunk;\n\n    // Try to parse as complete JSON first\n    try {\n      const parsed = JSON.parse(this.buffer);\n      // We have complete JSON, now validate it\n      const validationResult = this.schema.safeParse(parsed);\n\n      if (validationResult.success) {\n        return {\n          isComplete: true,\n          data: validationResult.data,\n          validationStatus: 'valid',\n        };\n      } else {\n        return {\n          isComplete: true,\n          data: parsed,\n          validationStatus: 'invalid',\n          errors: validationResult.error.issues.map((err) => ({\n            path: err.path.join('.'),\n            message: err.message,\n          })),\n        };\n      }\n    } catch {\n      // JSON is incomplete, try partial parsing\n      const partialData = this.parsePartialJSON(this.buffer);\n\n      if (Object.keys(partialData).length > 0) {\n        return {\n          isComplete: false,\n          partialData: partialData as Partial<T>,\n          validationStatus: 'partial',\n        };\n      }\n\n      return {\n        isComplete: false,\n        validationStatus: 'partial',\n      };\n    }\n  }\n\n  private parsePartialJSON(str: string): Record<string, unknown> {\n    const result: Record<string, unknown> = {};\n\n    // Extract key-value pairs, including incomplete ones\n    // Match pattern: \"key\": \"value\" OR \"key\": \"incomplete\n    const keyValueRegex = /\"([^\"]+)\":\\s*(?:\"([^\"]*)\"?|(\\d+))/g;\n    let match;\n\n    while ((match = keyValueRegex.exec(str)) !== null) {\n      const [, key, stringValue, numberValue] = match;\n\n      if (key && stringValue !== undefined) {\n        result[key] = stringValue;\n      } else if (key && numberValue !== undefined) {\n        result[key] = parseInt(numberValue, 10);\n      }\n    }\n\n    return result;\n  }\n\n  reset(): void {\n    this.buffer = '';\n  }\n}\n\n// Helper function to create mock streams for testing\nexport function createMockStream(chunks: string[]): ReadableStream<Uint8Array> {\n  let index = 0;\n\n  return new ReadableStream({\n    async pull(controller) {\n      if (index < chunks.length) {\n        const encoder = new TextEncoder();\n        controller.enqueue(encoder.encode(chunks[index]));\n        index++;\n      } else {\n        controller.close();\n      }\n    },\n  });\n}\n"]}