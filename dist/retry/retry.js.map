{"version":3,"file":"retry.js","sourceRoot":"","sources":["../../src/retry/retry.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,oBAAoB,EAAE,MAAM,SAAS,CAAC;AAC/C,OAAO,EAAE,gBAAgB,EAAE,QAAQ,EAAE,MAAM,UAAU,CAAC;AAEtD;;GAEG;AACH,MAAM,UAAU,gBAAgB,CAC9B,OAAe,EACf,YAAoB,EACpB,UAAkB,EAClB,QAAiB;IAEjB,MAAM,KAAK,GAAG,YAAY,GAAG,IAAI,CAAC,GAAG,CAAC,UAAU,EAAE,OAAO,CAAC,CAAC;IAC3D,OAAO,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,GAAG,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC;AACtD,CAAC;AAED;;;GAGG;AACH,MAAM,UAAU,UAAU,CAAC,KAAa;IACtC,OAAO,KAAK,GAAG,CAAC,GAAG,GAAG,IAAI,CAAC,MAAM,EAAE,GAAG,GAAG,CAAC,CAAC;AAC7C,CAAC;AAED;;GAEG;AACH,SAAS,KAAK,CAAC,EAAU;IACvB,OAAO,IAAI,OAAO,CAAC,CAAC,OAAO,EAAE,EAAE,CAAC,UAAU,CAAC,OAAO,EAAE,EAAE,CAAC,CAAC,CAAC;AAC3D,CAAC;AAED;;GAEG;AACH,MAAM,CAAC,KAAK,UAAU,KAAK,CAAI,EAAoB,EAAE,MAAoB;IACvE,MAAM,EACJ,UAAU,EACV,YAAY,EACZ,QAAQ,EACR,iBAAiB,EACjB,MAAM,EACN,eAAe,EAAE,qBAAqB,EACtC,OAAO,GACR,GAAG,EAAE,GAAG,oBAAoB,EAAE,GAAG,MAAM,EAAE,CAAC;IAE3C,IAAI,SAA4B,CAAC;IAEjC,KAAK,IAAI,OAAO,GAAG,CAAC,EAAE,OAAO,IAAI,UAAU,EAAE,OAAO,EAAE,EAAE,CAAC;QACvD,IAAI,CAAC;YACH,OAAO,MAAM,EAAE,EAAE,CAAC;QACpB,CAAC;QAAC,OAAO,KAAK,EAAE,CAAC;YACf,SAAS,GAAG,KAAc,CAAC;YAE3B,2BAA2B;YAC3B,IAAI,OAAO,KAAK,UAAU,IAAI,CAAC,gBAAgB,CAAC,SAAS,EAAE,qBAAqB,CAAC,EAAE,CAAC;gBAClF,MAAM,SAAS,CAAC;YAClB,CAAC;YAED,kBAAkB;YAClB,IAAI,KAAK,GAAG,gBAAgB,CAAC,OAAO,EAAE,YAAY,EAAE,iBAAiB,EAAE,QAAQ,CAAC,CAAC;YAEjF,+BAA+B;YAC/B,IAAI,SAAS,YAAY,QAAQ,IAAI,SAAS,CAAC,UAAU,EAAE,CAAC;gBAC1D,KAAK,GAAG,SAAS,CAAC,UAAU,GAAG,IAAI,CAAC,CAAC,kCAAkC;YACzE,CAAC;iBAAM,IAAI,YAAY,IAAI,SAAS,IAAI,OAAO,SAAS,CAAC,UAAU,KAAK,QAAQ,EAAE,CAAC;gBACjF,KAAK,GAAG,SAAS,CAAC,UAAU,GAAG,IAAI,CAAC;YACtC,CAAC;YAED,0BAA0B;YAC1B,IAAI,MAAM,EAAE,CAAC;gBACX,KAAK,GAAG,UAAU,CAAC,KAAK,CAAC,CAAC;YAC5B,CAAC;YAED,sBAAsB;YACtB,IAAI,OAAO,EAAE,CAAC;gBACZ,OAAO,CAAC,OAAO,GAAG,CAAC,EAAE,SAAS,EAAE,KAAK,CAAC,CAAC;YACzC,CAAC;YAED,uBAAuB;YACvB,MAAM,KAAK,CAAC,KAAK,CAAC,CAAC;QACrB,CAAC;IACH,CAAC;IAED,wDAAwD;IACxD,MAAM,SAAS,CAAC;AAClB,CAAC;AAED;;GAEG;AACH,MAAM,UAAU,SAAS,CACvB,EAAK,EACL,MAAoB;IAEpB,OAAO,CAAC,KAAK,EAAE,GAAG,IAAmB,EAAE,EAAE;QACvC,OAAO,KAAK,CAAC,GAAG,EAAE,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,EAAE,MAAM,CAAC,CAAC;IAC1C,CAAC,CAAM,CAAC;AACV,CAAC","sourcesContent":["import type { RetryConfig } from './types';\nimport { DEFAULT_RETRY_CONFIG } from './types';\nimport { isRetryableError, LLMError } from './errors';\n\n/**\n * Calculate exponential backoff delay\n */\nexport function calculateBackoff(\n  attempt: number,\n  initialDelay: number,\n  multiplier: number,\n  maxDelay?: number,\n): number {\n  const delay = initialDelay * Math.pow(multiplier, attempt);\n  return maxDelay ? Math.min(delay, maxDelay) : delay;\n}\n\n/**\n * Add jitter to a delay value\n * Returns a value between 50% and 100% of the original delay\n */\nexport function withJitter(delay: number): number {\n  return delay * (0.5 + Math.random() * 0.5);\n}\n\n/**\n * Sleep for a specified number of milliseconds\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\n/**\n * Retry a function with exponential backoff\n */\nexport async function retry<T>(fn: () => Promise<T>, config?: RetryConfig): Promise<T> {\n  const {\n    maxRetries,\n    initialDelay,\n    maxDelay,\n    backoffMultiplier,\n    jitter,\n    retryableErrors: customRetryableErrors,\n    onRetry,\n  } = { ...DEFAULT_RETRY_CONFIG, ...config };\n\n  let lastError: Error | undefined;\n\n  for (let attempt = 0; attempt <= maxRetries; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error as Error;\n\n      // Check if we should retry\n      if (attempt === maxRetries || !isRetryableError(lastError, customRetryableErrors)) {\n        throw lastError;\n      }\n\n      // Calculate delay\n      let delay = calculateBackoff(attempt, initialDelay, backoffMultiplier, maxDelay);\n\n      // Check for Retry-After header\n      if (lastError instanceof LLMError && lastError.retryAfter) {\n        delay = lastError.retryAfter * 1000; // Convert seconds to milliseconds\n      } else if ('retryAfter' in lastError && typeof lastError.retryAfter === 'number') {\n        delay = lastError.retryAfter * 1000;\n      }\n\n      // Apply jitter if enabled\n      if (jitter) {\n        delay = withJitter(delay);\n      }\n\n      // Call retry callback\n      if (onRetry) {\n        onRetry(attempt + 1, lastError, delay);\n      }\n\n      // Wait before retrying\n      await sleep(delay);\n    }\n  }\n\n  // This should never be reached, but TypeScript needs it\n  throw lastError;\n}\n\n/**\n * Create a retryable version of a function\n */\nexport function withRetry<T extends (...args: unknown[]) => Promise<unknown>>(\n  fn: T,\n  config?: RetryConfig,\n): T {\n  return (async (...args: Parameters<T>) => {\n    return retry(() => fn(...args), config);\n  }) as T;\n}\n"]}