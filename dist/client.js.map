{"version":3,"file":"client.js","sourceRoot":"","sources":["../src/client.ts"],"names":[],"mappings":"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","sourcesContent":["import { z } from 'zod';\nimport type {\n  ProviderName,\n  ProviderChatRequest,\n  ProviderChatResponse,\n  TypedProvider,\n  ModelInfo,\n  ProviderModels,\n  OpenAIChatRequest,\n  AnthropicChatRequest,\n  GeminiChatRequest,\n} from './providers/types';\nimport type { Message, Tool, ToolCall } from './providers/provider';\nimport type { RetryConfig } from './retry/types';\nimport { OpenAIProvider } from './providers/openai';\nimport { AnthropicProvider } from './providers/anthropic';\nimport { GeminiProvider } from './providers/gemini';\n\n// Client configuration\nexport interface LLMConfig<P extends ProviderName> {\n  provider: P;\n  apiKey: string;\n  model: ProviderModels[P];\n  defaultOptions?: {\n    temperature?: number;\n    maxTokens?: number;\n    topP?: number;\n    frequencyPenalty?: number;\n    presencePenalty?: number;\n  };\n  retry?: RetryConfig;\n}\n\n// Tool definition configuration\nexport interface ToolConfig<T extends z.ZodSchema> {\n  name: string;\n  description: string;\n  schema: T;\n  execute: (params: z.infer<T>) => Promise<unknown>;\n}\n\n// Tool with execution capability\nexport interface ExecutableTool<T extends z.ZodSchema = z.ZodSchema> extends Tool {\n  execute: (params: z.infer<T>) => Promise<unknown>;\n}\n\n// Tool execution result\nexport interface ToolResult {\n  toolCallId: string;\n  result: unknown;\n  error?: string;\n}\n\n// Base chat options without provider-specific features\nexport interface BaseChatOptions<T = string> {\n  messages: Message[];\n  temperature?: number;\n  maxTokens?: number;\n  stream?: boolean;\n  schema?: z.ZodSchema<T>;\n  tools?: Tool[];\n  toolChoice?: 'auto' | 'required' | 'none' | { name: string };\n}\n\n// Provider-specific chat options\nexport type ChatOptions<P extends ProviderName = ProviderName, T = string> = BaseChatOptions<T> & {\n  features?: P extends 'openai'\n    ? OpenAIChatRequest['features']\n    : P extends 'anthropic'\n      ? AnthropicChatRequest['features']\n      : P extends 'gemini'\n        ? GeminiChatRequest['features']\n        : never;\n};\n\nexport type StreamOptions<P extends ProviderName = ProviderName, T = string> = ChatOptions<P, T>;\n\nexport type DefineToolOptions<T extends z.ZodSchema = z.ZodSchema> = ToolConfig<T>;\n\nexport type ExecuteToolsOptions = ToolCall[];\n\n// Main client interface\nexport interface LLMClient<P extends ProviderName> {\n  readonly provider: P;\n  readonly apiKey: string;\n  readonly model: ProviderModels[P];\n  readonly defaultOptions?: LLMConfig<P>['defaultOptions'];\n  readonly retry?: RetryConfig;\n\n  // Core methods\n  chat<T = string>(options: ChatOptions<P, T>): Promise<ProviderChatResponse<P, T>>;\n\n  stream<T = string>(\n    options: StreamOptions<P, T>,\n  ): Promise<{\n    [Symbol.asyncIterator](): AsyncIterator<T>;\n    complete(): Promise<ProviderChatResponse<P, T>>;\n  }>;\n\n  // Tool methods\n  defineTool<T extends z.ZodSchema>(config: DefineToolOptions<T>): ExecutableTool<T>;\n  executeTools(toolCalls: ExecuteToolsOptions): Promise<ToolResult[]>;\n\n  // Model methods\n  listModels(): Promise<ModelInfo[]>;\n}\n\n// Implementation class\nexport class LLMClientImpl<P extends ProviderName> implements LLMClient<P> {\n  private tools = new Map<string, ExecutableTool>();\n\n  constructor(\n    public readonly provider: P,\n    public readonly apiKey: string,\n    public readonly model: ProviderModels[P],\n    public readonly defaultOptions?: LLMConfig<P>['defaultOptions'],\n    public readonly retry?: RetryConfig,\n    private providerImpl?: TypedProvider<P>,\n  ) {}\n\n  async chat<T = string>(options: ChatOptions<P, T>): Promise<ProviderChatResponse<P, T>> {\n    if (!this.providerImpl) {\n      throw new Error(`Provider ${this.provider} not implemented yet`);\n    }\n\n    const request: ProviderChatRequest<P> = {\n      messages: options.messages,\n      temperature: options.temperature ?? this.defaultOptions?.temperature,\n      maxTokens: options.maxTokens ?? this.defaultOptions?.maxTokens,\n      stream: options.stream,\n      schema: options.schema,\n      tools: options.tools,\n      toolChoice: options.toolChoice,\n      features: options.features,\n      model: this.model,\n    } as ProviderChatRequest<P>;\n\n    const response = await this.providerImpl.chat<T>(request);\n\n    return response;\n  }\n\n  async stream<T = string>(\n    options: StreamOptions<P, T>,\n  ): Promise<{\n    [Symbol.asyncIterator](): AsyncIterator<T>;\n    complete(): Promise<ProviderChatResponse<P, T>>;\n  }> {\n    if (!this.providerImpl) {\n      throw new Error(`Provider ${this.provider} not implemented yet`);\n    }\n\n    const request: ProviderChatRequest<P> = {\n      messages: options.messages,\n      temperature: options.temperature ?? this.defaultOptions?.temperature,\n      maxTokens: options.maxTokens ?? this.defaultOptions?.maxTokens,\n      stream: true,\n      schema: options.schema,\n      tools: options.tools,\n      toolChoice: options.toolChoice,\n      features: options.features,\n      model: this.model,\n    } as ProviderChatRequest<P>;\n\n    return this.providerImpl.stream(request);\n  }\n\n  defineTool<T extends z.ZodSchema>(config: ToolConfig<T>): ExecutableTool<T> {\n    const tool: ExecutableTool<T> = {\n      name: config.name,\n      description: config.description,\n      parameters: config.schema,\n      execute: config.execute,\n    };\n\n    this.tools.set(config.name, tool);\n    return tool;\n  }\n\n  async executeTools(toolCalls: ToolCall[]): Promise<ToolResult[]> {\n    const results: ToolResult[] = [];\n\n    for (const call of toolCalls) {\n      const tool = this.tools.get(call.name);\n      if (!tool) {\n        results.push({\n          toolCallId: call.id,\n          result: null,\n          error: `Tool ${call.name} not found`,\n        });\n        continue;\n      }\n\n      try {\n        const params = tool.parameters.parse(call.arguments);\n        const result = await tool.execute(params);\n        results.push({\n          toolCallId: call.id,\n          result,\n        });\n      } catch (error) {\n        results.push({\n          toolCallId: call.id,\n          result: null,\n          error: error instanceof Error ? error.message : String(error),\n        });\n      }\n    }\n\n    return results;\n  }\n\n  async listModels(): Promise<ModelInfo[]> {\n    if (!this.providerImpl) {\n      throw new Error('Provider not initialized');\n    }\n    return this.providerImpl.listModels();\n  }\n}\n\n// Factory functions\nexport function createLLM<P extends ProviderName>(config: LLMConfig<P>): LLMClient<P> {\n  let providerImpl: TypedProvider<P> | undefined;\n\n  // Create provider implementation based on provider name\n  switch (config.provider) {\n    case 'openai':\n      providerImpl = new OpenAIProvider(\n        config.apiKey,\n        undefined,\n        config.retry,\n      ) as unknown as TypedProvider<P>;\n      break;\n    case 'anthropic':\n      providerImpl = new AnthropicProvider(\n        config.apiKey,\n        undefined,\n        config.retry,\n      ) as unknown as TypedProvider<P>;\n      break;\n    case 'gemini':\n      providerImpl = new GeminiProvider(\n        config.apiKey,\n        undefined,\n        config.retry,\n      ) as unknown as TypedProvider<P>;\n      break;\n  }\n\n  return new LLMClientImpl(\n    config.provider,\n    config.apiKey,\n    config.model,\n    config.defaultOptions,\n    config.retry,\n    providerImpl,\n  );\n}\n\nexport function createOpenAILLM(\n  config: Omit<LLMConfig<'openai'>, 'provider'>,\n): LLMClient<'openai'> {\n  return createLLM({ ...config, provider: 'openai' });\n}\n\nexport function createAnthropicLLM(\n  config: Omit<LLMConfig<'anthropic'>, 'provider'>,\n): LLMClient<'anthropic'> {\n  return createLLM({ ...config, provider: 'anthropic' });\n}\n\nexport function createGeminiLLM(\n  config: Omit<LLMConfig<'gemini'>, 'provider'>,\n): LLMClient<'gemini'> {\n  return createLLM({ ...config, provider: 'gemini' });\n}\n"]}