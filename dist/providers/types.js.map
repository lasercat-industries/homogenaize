{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/providers/types.ts"],"names":[],"mappings":"AAiHA,cAAc;AACd,MAAM,UAAU,gBAAgB,CAC9B,SAA0B,EAC1B,QAAsB;IAEtB,OAAO,QAAQ,KAAK,QAAQ,CAAC;AAC/B,CAAC;AAED,MAAM,UAAU,mBAAmB,CACjC,SAA0B,EAC1B,QAAsB;IAEtB,OAAO,QAAQ,KAAK,WAAW,CAAC;AAClC,CAAC;AAED,MAAM,UAAU,gBAAgB,CAC9B,SAA0B,EAC1B,QAAsB;IAEtB,OAAO,QAAQ,KAAK,QAAQ,CAAC;AAC/B,CAAC","sourcesContent":["import type { ChatRequest, ChatResponse, Provider, ModelInfo } from './provider';\nimport type { OpenaiModel, AnthropicModel, GeminiModel } from '../generated/model-types';\n\n// Re-export ModelInfo from provider\nexport type { ModelInfo };\n\n// Provider names as const\nexport type ProviderName = 'openai' | 'anthropic' | 'gemini';\n\n// Model types mapped to providers\nexport type ProviderModels = {\n  openai: OpenaiModel;\n  anthropic: AnthropicModel;\n  gemini: GeminiModel;\n};\n\n// Provider-specific request types\nexport interface OpenAIChatRequest extends ChatRequest {\n  features?: {\n    logprobs?: boolean;\n    topLogprobs?: number;\n    seed?: number;\n    responseFormat?: { type: 'json_object' | 'json_schema'; json_schema?: unknown };\n  };\n}\n\nexport interface AnthropicChatRequest extends ChatRequest {\n  features?: {\n    thinking?: boolean;\n    cacheControl?: boolean;\n    maxThinkingTokens?: number;\n  };\n}\n\nexport interface GeminiChatRequest extends ChatRequest {\n  features?: {\n    safetySettings?: Array<{\n      category: string;\n      threshold: string;\n    }>;\n    generationConfig?: {\n      stopSequences?: string[];\n      candidateCount?: number;\n      maxOutputTokens?: number;\n      temperature?: number;\n    };\n  };\n}\n\n// Union type for all provider requests\nexport type ProviderChatRequest<P extends ProviderName> = P extends 'openai'\n  ? OpenAIChatRequest\n  : P extends 'anthropic'\n    ? AnthropicChatRequest\n    : P extends 'gemini'\n      ? GeminiChatRequest\n      : never;\n\n// Extended response type with provider-specific fields\nexport interface OpenAIChatResponse<T = string> extends ChatResponse<T> {\n  logprobs?: Array<{\n    token: string;\n    logprob: number;\n    topLogprobs?: Array<{ token: string; logprob: number }>;\n  }>;\n  systemFingerprint?: string;\n}\n\nexport interface AnthropicChatResponse<T = string> extends ChatResponse<T> {\n  thinking?: string;\n  cacheInfo?: {\n    cacheCreationInputTokens?: number;\n    cacheReadInputTokens?: number;\n  };\n  stopReason?: string;\n}\n\nexport interface GeminiChatResponse<T = string> extends ChatResponse<T> {\n  safetyRatings?: Array<{\n    category: string;\n    probability: string;\n  }>;\n  citationMetadata?: {\n    citations: Array<{\n      startIndex?: number;\n      endIndex?: number;\n      uri?: string;\n      license?: string;\n    }>;\n  };\n}\n\n// Union type for all provider responses\nexport type ProviderChatResponse<P extends ProviderName, T = string> = P extends 'openai'\n  ? OpenAIChatResponse<T>\n  : P extends 'anthropic'\n    ? AnthropicChatResponse<T>\n    : P extends 'gemini'\n      ? GeminiChatResponse<T>\n      : never;\n\n// Provider with specific type\nexport interface TypedProvider<P extends ProviderName> extends Provider {\n  readonly name: P;\n  chat<T = string>(request: ProviderChatRequest<P>): Promise<ProviderChatResponse<P, T>>;\n  stream<T = string>(\n    request: ProviderChatRequest<P>,\n  ): Promise<{\n    [Symbol.asyncIterator](): AsyncIterator<T>;\n    complete(): Promise<ProviderChatResponse<P, T>>;\n  }>;\n}\n\n// Type guards\nexport function isOpenAIResponse<T>(\n  _response: ChatResponse<T>,\n  provider: ProviderName,\n): _response is OpenAIChatResponse<T> {\n  return provider === 'openai';\n}\n\nexport function isAnthropicResponse<T>(\n  _response: ChatResponse<T>,\n  provider: ProviderName,\n): _response is AnthropicChatResponse<T> {\n  return provider === 'anthropic';\n}\n\nexport function isGeminiResponse<T>(\n  _response: ChatResponse<T>,\n  provider: ProviderName,\n): _response is GeminiChatResponse<T> {\n  return provider === 'gemini';\n}\n"]}