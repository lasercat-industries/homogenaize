{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/providers/types.ts"],"names":[],"mappings":"AAiHA,cAAc;AACd,MAAM,UAAU,gBAAgB,CAC9B,SAA0B,EAC1B,QAAsB;IAEtB,OAAO,QAAQ,KAAK,QAAQ,CAAC;AAC/B,CAAC;AAED,MAAM,UAAU,mBAAmB,CACjC,SAA0B,EAC1B,QAAsB;IAEtB,OAAO,QAAQ,KAAK,WAAW,CAAC;AAClC,CAAC;AAED,MAAM,UAAU,gBAAgB,CAC9B,SAA0B,EAC1B,QAAsB;IAEtB,OAAO,QAAQ,KAAK,QAAQ,CAAC;AAC/B,CAAC","sourcesContent":["import type { ChatRequest, ChatResponse, Provider } from './provider';\nimport type { OpenaiModel, AnthropicModel, GeminiModel } from '../generated/model-types';\n\n// Provider names as const\nexport type ProviderName = 'openai' | 'anthropic' | 'gemini';\n\n// Model types mapped to providers\nexport type ProviderModels = {\n  openai: OpenaiModel;\n  anthropic: AnthropicModel;\n  gemini: GeminiModel;\n};\n\n// Model information\nexport interface ModelInfo {\n  id: string;\n  name: string;\n  description?: string;\n  created?: number;\n  capabilities?: {\n    chat?: boolean;\n    completions?: boolean;\n    embeddings?: boolean;\n    fineTuning?: boolean;\n    vision?: boolean;\n    functionCalling?: boolean;\n  };\n  contextWindow?: number;\n  maxOutputTokens?: number;\n}\n\n// Provider-specific features\nexport interface ProviderFeatures {\n  openai: {\n    logprobs?: boolean;\n    topLogprobs?: number;\n    seed?: number;\n    responseFormat?: { type: 'json_object' | 'json_schema'; json_schema?: unknown };\n  };\n  anthropic: {\n    thinking?: boolean;\n    cacheControl?: boolean;\n    maxThinkingTokens?: number;\n  };\n  gemini: {\n    safetySettings?: Array<{\n      category: string;\n      threshold: string;\n    }>;\n    generationConfig?: {\n      stopSequences?: string[];\n      candidateCount?: number;\n      maxOutputTokens?: number;\n      temperature?: number;\n    };\n  };\n}\n\n// Provider-specific responses\nexport interface ProviderResponses {\n  openai: {\n    logprobs?: Array<{\n      token: string;\n      logprob: number;\n      topLogprobs?: Array<{ token: string; logprob: number }>;\n    }>;\n    systemFingerprint?: string;\n  };\n  anthropic: {\n    thinking?: string;\n    cacheInfo?: {\n      cacheCreationInputTokens?: number;\n      cacheReadInputTokens?: number;\n    };\n    stopReason?: string;\n  };\n  gemini: {\n    safetyRatings?: Array<{\n      category: string;\n      probability: string;\n    }>;\n    citationMetadata?: {\n      citations: Array<{\n        startIndex?: number;\n        endIndex?: number;\n        uri?: string;\n        license?: string;\n      }>;\n    };\n  };\n}\n\n// Extended request type with provider features\nexport interface ProviderChatRequest<P extends ProviderName> extends ChatRequest {\n  features?: ProviderFeatures[P];\n}\n\n// Extended response type with provider-specific fields\nexport type ProviderChatResponse<P extends ProviderName, T = string> = ChatResponse<T> &\n  ProviderResponses[P];\n\n// Provider with specific type\nexport interface TypedProvider<P extends ProviderName> extends Provider {\n  readonly name: P;\n  chat<T = string>(request: ProviderChatRequest<P>): Promise<ProviderChatResponse<P, T>>;\n  stream<T = string>(\n    request: ProviderChatRequest<P>,\n  ): Promise<{\n    [Symbol.asyncIterator](): AsyncIterator<T>;\n    complete(): Promise<ProviderChatResponse<P, T>>;\n  }>;\n}\n\n// Type guards\nexport function isOpenAIResponse<T>(\n  _response: ChatResponse<T>,\n  provider: ProviderName,\n): _response is ProviderChatResponse<'openai', T> {\n  return provider === 'openai';\n}\n\nexport function isAnthropicResponse<T>(\n  _response: ChatResponse<T>,\n  provider: ProviderName,\n): _response is ProviderChatResponse<'anthropic', T> {\n  return provider === 'anthropic';\n}\n\nexport function isGeminiResponse<T>(\n  _response: ChatResponse<T>,\n  provider: ProviderName,\n): _response is ProviderChatResponse<'gemini', T> {\n  return provider === 'gemini';\n}\n"]}