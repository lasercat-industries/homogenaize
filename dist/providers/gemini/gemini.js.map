{"version":3,"file":"gemini.js","sourceRoot":"","sources":["../../../src/providers/gemini/gemini.ts"],"names":[],"mappings":"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","sourcesContent":["import { z } from 'zod';\nimport type { StreamingResponse, ProviderCapabilities, ToolCall, Message } from '../provider';\nimport type { TypedProvider, ProviderChatRequest, ProviderChatResponse, ModelInfo } from '../types';\nimport { LLMError } from '../../retry/errors';\nimport { retry } from '../../retry';\nimport type { RetryConfig } from '../../retry/types';\n\ntype JSONSchemaType = {\n  type: string;\n  properties?: Record<string, JSONSchemaType>;\n  items?: JSONSchemaType;\n  required?: string[];\n  enum?: unknown[];\n  const?: unknown;\n  [key: string]: unknown;\n};\n\n// Gemini-specific types\ninterface GeminiContent {\n  role: 'user' | 'model';\n  parts: GeminiPart[];\n}\n\ntype GeminiPart =\n  | { text: string }\n  | { functionCall: { name: string; args: unknown } }\n  | { functionResponse: { name: string; response: unknown } };\n\ninterface GeminiTool {\n  functionDeclarations: Array<{\n    name: string;\n    description: string;\n    parameters: JSONSchemaType;\n  }>;\n}\n\ninterface GeminiRequest {\n  contents: GeminiContent[];\n  systemInstruction?: {\n    parts: Array<{ text: string }>;\n  };\n  generationConfig?: {\n    temperature?: number;\n    topK?: number;\n    topP?: number;\n    candidateCount?: number;\n    maxOutputTokens?: number;\n    stopSequences?: string[];\n    responseMimeType?: string;\n  };\n  safetySettings?: Array<{\n    category: string;\n    threshold: string;\n  }>;\n  tools?: GeminiTool[];\n  toolConfig?: {\n    functionCallingConfig: {\n      mode: 'AUTO' | 'ANY' | 'NONE';\n    };\n  };\n}\n\ninterface GeminiResponse {\n  candidates: Array<{\n    content: GeminiContent;\n    finishReason: string;\n    index: number;\n    safetyRatings?: Array<{\n      category: string;\n      probability: string;\n    }>;\n  }>;\n  usageMetadata?: {\n    promptTokenCount: number;\n    candidatesTokenCount: number;\n    totalTokenCount: number;\n  };\n}\n\n// Helper to convert Zod schema to Gemini-compatible JSON Schema\nfunction zodToGeminiSchema(schema: z.ZodSchema): JSONSchemaType {\n  // Handle both Zod v3 and v4 structure\n  const zodType = schema._def || (schema as z.ZodTypeAny & { def?: unknown }).def;\n\n  if (!zodType) {\n    throw new Error('Invalid Zod schema: missing _def property');\n  }\n\n  function processZodType(def: any): JSONSchemaType {\n    switch (def.type) {\n      case 'string': {\n        const result: JSONSchemaType = { type: 'string' };\n\n        // Check for format constraints\n        if (def.checks) {\n          for (const check of def.checks) {\n            // Handle both Zod v3 and v4 check structures\n            const checkDef = check.def || check._def || check;\n\n            if (checkDef.kind === 'uuid' || checkDef.format === 'uuid') {\n              // Gemini doesn't support 'uuid' format, use pattern instead\n              result.pattern =\n                '^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[4][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$';\n            } else if (checkDef.kind === 'email' || checkDef.format === 'email') {\n              // Gemini doesn't support 'email' format, use pattern instead\n              result.pattern = '^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$';\n            } else if (checkDef.kind === 'datetime' || checkDef.format === 'date-time') {\n              // Gemini supports date-time format\n              result.format = 'date-time';\n            } else if (checkDef.kind === 'min') {\n              result.minLength = checkDef.value;\n            } else if (checkDef.kind === 'max') {\n              result.maxLength = checkDef.value;\n            }\n          }\n        }\n\n        return result;\n      }\n      case 'number': {\n        const numResult: JSONSchemaType = { type: 'number' };\n\n        // Check for number constraints\n        if (def.checks) {\n          for (const check of def.checks) {\n            const checkDef = check.def || check._def || check;\n\n            switch (checkDef.kind) {\n              case 'int': {\n                numResult.type = 'integer';\n                break;\n              }\n              case 'min': {\n                numResult.minimum = checkDef.value;\n                break;\n              }\n              case 'max': {\n                numResult.maximum = checkDef.value;\n                break;\n              }\n              case 'multipleOf': {\n                numResult.multipleOf = checkDef.value;\n                break;\n              }\n              // No default\n            }\n          }\n        }\n\n        return numResult;\n      }\n      case 'boolean':\n        return { type: 'boolean' };\n      case 'array': {\n        const itemDef =\n          def.valueType?._def ||\n          def.valueType?.def ||\n          def.valueType ||\n          def.element?._def ||\n          def.element?.def ||\n          def.element;\n        const arrayResult: JSONSchemaType = {\n          type: 'array',\n          items: itemDef ? processZodType(itemDef) : { type: 'string' },\n        };\n\n        // Check for array constraints\n        if (def.checks) {\n          for (const check of def.checks) {\n            const checkDef = check.def || check._def || check;\n\n            switch (checkDef.kind) {\n              case 'min': {\n                arrayResult.minItems = checkDef.value;\n                break;\n              }\n              case 'max': {\n                arrayResult.maxItems = checkDef.value;\n                break;\n              }\n              case 'length': {\n                arrayResult.minItems = checkDef.value;\n                arrayResult.maxItems = checkDef.value;\n                break;\n              }\n              // No default\n            }\n          }\n        }\n\n        return arrayResult;\n      }\n      case 'object': {\n        const properties: Record<string, JSONSchemaType> = {};\n        const required: string[] = [];\n\n        // Access shape directly from def\n        const shape = def.shape || {};\n        for (const [key, value] of Object.entries(shape)) {\n          // Handle both Zod v3 and v4 - in v4, each field has its own _def\n          const fieldDef = (value as any)._def || (value as any).def || value;\n          properties[key] = processZodType(fieldDef);\n          // Check if field is optional\n          if (fieldDef.type !== 'optional') {\n            required.push(key);\n          }\n        }\n\n        return {\n          type: 'object',\n          properties,\n          required: required.length > 0 ? required : undefined,\n        };\n      }\n      case 'optional': {\n        const innerDef = def.innerType?._def || def.innerType?.def || def.innerType;\n        return innerDef ? processZodType(innerDef) : { type: 'string' };\n      }\n      case 'enum':\n        return {\n          type: 'string',\n          enum: def.values,\n        };\n      case 'literal':\n        return {\n          type: typeof def.value,\n          const: def.value,\n        };\n      default:\n        // Fallback for unsupported types\n        return { type: 'string' };\n    }\n  }\n\n  return processZodType(zodType);\n}\n\nexport class GeminiProvider implements TypedProvider<'gemini'> {\n  readonly name = 'gemini' as const;\n  readonly capabilities: ProviderCapabilities = {\n    streaming: true,\n    tools: true,\n    structuredOutput: true,\n    vision: true,\n    maxTokens: 1048576, // Gemini 1.5 Pro supports up to 1M tokens\n  };\n\n  private apiKey: string;\n  private baseURL = 'https://generativelanguage.googleapis.com/v1beta';\n  private retryConfig?: RetryConfig;\n\n  constructor(apiKey: string, baseURL?: string, retryConfig?: RetryConfig) {\n    this.apiKey = apiKey;\n    if (baseURL) {\n      this.baseURL = baseURL.replace(/\\/$/, ''); // Remove trailing slash\n    }\n    this.retryConfig = retryConfig;\n  }\n\n  async chat<T = string>(\n    request: ProviderChatRequest<'gemini'>,\n  ): Promise<ProviderChatResponse<'gemini', T>> {\n    const makeRequest = async () => {\n      const geminiRequest = this.transformRequest(request);\n      const model = request.model || 'gemini-1.5-pro-latest';\n\n      const response = await fetch(`${this.baseURL}/models/${model}:generateContent`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n          'x-goog-api-key': this.apiKey,\n        },\n        body: JSON.stringify(geminiRequest),\n      });\n\n      if (!response) {\n        throw new LLMError(\n          'Network error: No response received',\n          undefined,\n          'gemini',\n          request.model,\n        );\n      }\n\n      if (!response.ok) {\n        const error = (await response\n          .json()\n          .catch(() => ({ error: { message: response.statusText } }))) as {\n          error?: { message?: string };\n        };\n        const retryAfter = response.headers.get('Retry-After');\n        const errorMessage = `Gemini API error (${response.status}): ${error.error?.message || 'Unknown error'}`;\n        const llmError = new LLMError(errorMessage, response.status, 'gemini', request.model);\n        if (retryAfter) {\n          llmError.retryAfter = parseInt(retryAfter, 10);\n        }\n        throw llmError;\n      }\n\n      const data = (await response.json()) as GeminiResponse;\n      return this.transformResponse<T>(data, model, request.schema);\n    };\n\n    if (this.retryConfig) {\n      return retry(makeRequest, this.retryConfig);\n    }\n\n    return makeRequest();\n  }\n\n  async stream<T = string>(request: ProviderChatRequest<'gemini'>): Promise<StreamingResponse<T>> {\n    const geminiRequest = this.transformRequest(request);\n    const model = request.model || 'gemini-1.5-pro-latest';\n\n    const response = await fetch(`${this.baseURL}/models/${model}:streamGenerateContent?alt=sse`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'x-goog-api-key': this.apiKey,\n      },\n      body: JSON.stringify(geminiRequest),\n    });\n\n    if (!response.ok) {\n      const error = (await response\n        .json()\n        .catch(() => ({ error: { message: response.statusText } }))) as {\n        error?: { message?: string };\n      };\n      throw new Error(\n        `Gemini API error (${response.status}): ${error.error?.message || 'Unknown error'}`,\n      );\n    }\n\n    const reader = response.body!.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n    let content = '';\n    let usage = { promptTokenCount: 0, candidatesTokenCount: 0 };\n    let finishReason: string | undefined;\n\n    const streamResponse = {\n      async *[Symbol.asyncIterator](): AsyncIterator<T> {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n\n          const chunk = decoder.decode(value, { stream: true });\n          buffer += chunk;\n\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || '';\n\n          for (const line of lines) {\n            if (!line.trim()) continue;\n\n            try {\n              // Gemini might prefix lines with \"data: \" in SSE format\n              const jsonStr = line.startsWith('data: ') ? line.slice(6) : line;\n              const data: GeminiResponse = JSON.parse(jsonStr);\n\n              if (data.candidates && data.candidates[0]) {\n                const candidate = data.candidates[0];\n\n                // Extract text from parts\n                if (candidate.content && candidate.content.parts) {\n                  for (const part of candidate.content.parts) {\n                    if ('text' in part && part.text) {\n                      content += part.text;\n                      // For structured output, we can't yield partial JSON\n                      if (!request.schema) {\n                        yield part.text as T;\n                      }\n                    }\n                  }\n                }\n\n                // Update finish reason\n                if (candidate.finishReason) {\n                  finishReason = candidate.finishReason;\n                }\n              }\n\n              // Update usage metadata\n              if (data.usageMetadata) {\n                usage = data.usageMetadata;\n              }\n            } catch (e) {\n              // Ignore parsing errors\n            }\n          }\n        }\n      },\n\n      async complete(): Promise<ProviderChatResponse<'gemini', T>> {\n        // Drain any remaining content\n        for await (const _chunk of streamResponse) {\n          // Just consume\n        }\n\n        let parsedContent: T;\n        if (request.schema && content) {\n          try {\n            const parsed = JSON.parse(content);\n            parsedContent = request.schema.parse(parsed) as T;\n          } catch {\n            parsedContent = content as T;\n          }\n        } else {\n          parsedContent = content as T;\n        }\n\n        return {\n          content: parsedContent,\n          usage: {\n            inputTokens: usage.promptTokenCount,\n            outputTokens: usage.candidatesTokenCount,\n            totalTokens: usage.promptTokenCount + usage.candidatesTokenCount,\n          },\n          model,\n          finishReason: finishReason as any,\n        };\n      },\n    };\n\n    return streamResponse;\n  }\n\n  supportsFeature(feature: string): boolean {\n    return feature in this.capabilities && (this.capabilities as any)[feature] === true;\n  }\n\n  private transformRequest(request: ProviderChatRequest<'gemini'>): GeminiRequest {\n    // Extract system message if present\n    let systemInstruction: GeminiRequest['systemInstruction'];\n    const contents: GeminiContent[] = [];\n\n    for (const msg of request.messages) {\n      if (msg.role === 'system') {\n        systemInstruction = {\n          parts: [{ text: typeof msg.content === 'string' ? msg.content : '' }],\n        };\n      } else {\n        contents.push(this.transformMessage(msg));\n      }\n    }\n\n    const geminiRequest: GeminiRequest = {\n      contents,\n      systemInstruction,\n      generationConfig: {\n        temperature: request.temperature,\n        maxOutputTokens: request.maxTokens,\n      },\n    };\n\n    // Handle structured output via schema using forced tool calling\n    if (request.schema && !request.tools) {\n      // Create a hidden tool for structured output\n      const jsonSchema = zodToGeminiSchema(request.schema);\n      geminiRequest.tools = [\n        {\n          functionDeclarations: [\n            {\n              name: 'respond_with_structured_output',\n              description: 'Respond with structured data matching the required schema',\n              parameters: jsonSchema,\n            },\n          ],\n        },\n      ];\n      // Force the model to use this tool\n      geminiRequest.toolConfig = {\n        functionCallingConfig: { mode: 'ANY' },\n      };\n    }\n\n    // Handle Gemini-specific features\n    if (request.features) {\n      if (request.features.safetySettings) {\n        geminiRequest.safetySettings = request.features.safetySettings;\n      }\n    }\n\n    // Handle tools\n    if (request.tools) {\n      geminiRequest.tools = [\n        {\n          functionDeclarations: request.tools.map((tool) => ({\n            name: tool.name,\n            description: tool.description,\n            parameters: tool.parameters\n              ? zodToGeminiSchema(tool.parameters)\n              : { type: 'object', properties: {} },\n          })),\n        },\n      ];\n    }\n\n    // Handle tool choice\n    if (request.toolChoice) {\n      switch (request.toolChoice) {\n        case 'required': {\n          geminiRequest.toolConfig = {\n            functionCallingConfig: { mode: 'ANY' },\n          };\n          break;\n        }\n        case 'none': {\n          geminiRequest.toolConfig = {\n            functionCallingConfig: { mode: 'NONE' },\n          };\n          break;\n        }\n        case 'auto': {\n          geminiRequest.toolConfig = {\n            functionCallingConfig: { mode: 'AUTO' },\n          };\n          break;\n        }\n        // No default\n      }\n    }\n\n    return geminiRequest;\n  }\n\n  private transformMessage(message: Message): GeminiContent {\n    const role = message.role === 'assistant' ? 'model' : 'user';\n\n    if (typeof message.content === 'string') {\n      return {\n        role,\n        parts: [{ text: message.content }],\n      };\n    }\n\n    // Handle multi-modal content\n    const parts: GeminiPart[] = message.content.map((c) => {\n      if (c.type === 'text') {\n        return { text: c.text || '' };\n      }\n      // Handle image content if needed\n      return { text: '[Image content]' };\n    });\n\n    return { role, parts };\n  }\n\n  private transformResponse<T>(\n    response: GeminiResponse,\n    model: string,\n    schema?: z.ZodSchema,\n  ): ProviderChatResponse<'gemini', T> {\n    const candidate = response.candidates[0];\n    if (!candidate) {\n      throw new Error('No candidate in response');\n    }\n    let content = '';\n    const toolCalls: ToolCall[] = [];\n\n    // Process content parts\n    if (candidate.content && candidate.content.parts) {\n      for (let i = 0; i < candidate.content.parts.length; i++) {\n        const part = candidate.content.parts[i];\n        if (part && 'text' in part && part.text) {\n          content += part.text;\n        } else if (part && 'functionCall' in part) {\n          toolCalls.push({\n            id: `${part.functionCall.name}_${i}`,\n            name: part.functionCall.name,\n            arguments: part.functionCall.args,\n          });\n        }\n      }\n    }\n\n    let parsedContent: T;\n\n    // If we used schema-based tool calling, extract the structured data from tool call\n    const structuredOutputTool = toolCalls.find(\n      (tc) => tc.name === 'respond_with_structured_output',\n    );\n    if (schema && structuredOutputTool) {\n      try {\n        parsedContent = schema.parse(structuredOutputTool.arguments) as T;\n      } catch {\n        parsedContent = content as T;\n      }\n    } else if (schema && content) {\n      try {\n        const parsed = JSON.parse(content);\n        parsedContent = schema.parse(parsed) as T;\n      } catch {\n        parsedContent = content as T;\n      }\n    } else {\n      parsedContent = content as T;\n    }\n\n    const result: ProviderChatResponse<'gemini', T> = {\n      content: parsedContent,\n      usage: response.usageMetadata\n        ? {\n            inputTokens: response.usageMetadata.promptTokenCount,\n            outputTokens: response.usageMetadata.candidatesTokenCount,\n            totalTokens: response.usageMetadata.totalTokenCount,\n          }\n        : {\n            inputTokens: 0,\n            outputTokens: 0,\n            totalTokens: 0,\n          },\n      model,\n      finishReason: candidate.finishReason as any,\n    };\n\n    // Only include tool calls if not using schema-based tool calling\n    // or if there are other tool calls besides the structured output tool\n    const nonStructuredToolCalls = toolCalls.filter(\n      (tc) => tc.name !== 'respond_with_structured_output',\n    );\n    if (nonStructuredToolCalls.length > 0 && !schema) {\n      result.toolCalls = nonStructuredToolCalls;\n    }\n\n    if (candidate.safetyRatings) {\n      result.safetyRatings = candidate.safetyRatings;\n    }\n\n    return result;\n  }\n\n  async listModels(): Promise<ModelInfo[]> {\n    const response = await fetch(`${this.baseURL}/models`, {\n      method: 'GET',\n      headers: {\n        'x-goog-api-key': this.apiKey,\n      },\n    });\n\n    if (!response.ok) {\n      const error = (await response\n        .json()\n        .catch(() => ({ error: { message: response.statusText } }))) as {\n        error?: { message?: string };\n      };\n      throw new LLMError(\n        `Gemini API error (${response.status}): ${error.error?.message || 'Unknown error'}`,\n        response.status,\n        'gemini',\n      );\n    }\n\n    const data = (await response.json()) as {\n      models: Array<{\n        name: string;\n        displayName: string;\n        description?: string;\n        supportedGenerationMethods?: string[];\n      }>;\n    };\n\n    return data.models.map((model) => ({\n      id: model.name.replace('models/', ''),\n      name: model.displayName,\n      description: model.description,\n    }));\n  }\n}\n"]}