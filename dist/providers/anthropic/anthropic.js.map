{"version":3,"file":"anthropic.js","sourceRoot":"","sources":["../../../src/providers/anthropic/anthropic.ts"],"names":[],"mappings":"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","sourcesContent":["import { z } from 'zod';\nimport type { StreamingResponse, ProviderCapabilities, ToolCall, Message } from '../provider';\nimport type { TypedProvider, ProviderChatRequest, ProviderChatResponse, ModelInfo } from '../types';\nimport type { RetryConfig } from '../../retry/types';\nimport { retry } from '../../retry';\nimport { LLMError } from '../../retry/errors';\n\ntype JSONSchemaType = {\n  type: string;\n  properties?: Record<string, JSONSchemaType>;\n  items?: JSONSchemaType;\n  required?: string[];\n  enum?: unknown[];\n  const?: unknown;\n  [key: string]: unknown;\n};\n\n// Anthropic-specific types\ninterface AnthropicMessage {\n  role: 'user' | 'assistant';\n  content: string | AnthropicContent[];\n}\n\ntype AnthropicContent =\n  | { type: 'text'; text: string }\n  | { type: 'tool_use'; id: string; name: string; input: unknown }\n  | { type: 'tool_result'; tool_use_id: string; content: string }\n  | { type: 'thinking'; text: string };\n\ninterface AnthropicTool {\n  name: string;\n  description: string;\n  input_schema: JSONSchemaType;\n}\n\ninterface AnthropicRequest {\n  model: string;\n  messages: AnthropicMessage[];\n  system?: string;\n  max_tokens: number;\n  temperature?: number;\n  top_p?: number;\n  top_k?: number;\n  stream?: boolean;\n  tools?: AnthropicTool[];\n  tool_choice?: { type: 'auto' | 'any' | 'tool'; name?: string };\n  max_thinking_tokens?: number;\n}\n\ninterface AnthropicResponse {\n  id: string;\n  type: 'message';\n  role: 'assistant';\n  model: string;\n  content: AnthropicContent[];\n  stop_reason: 'end_turn' | 'max_tokens' | 'stop_sequence' | 'tool_use';\n  stop_sequence: string | null;\n  usage: {\n    input_tokens: number;\n    output_tokens: number;\n    thinking_tokens?: number;\n  };\n}\n\n// Streaming event types\ninterface MessageStartEvent {\n  type: 'message_start';\n  message: {\n    id: string;\n    type: 'message';\n    role: 'assistant';\n    model: string;\n    content: [];\n    usage: {\n      input_tokens: number;\n      output_tokens: number;\n    };\n  };\n}\n\ninterface ContentBlockDeltaEvent {\n  type: 'content_block_delta';\n  index: number;\n  delta: {\n    type: 'text_delta';\n    text: string;\n  };\n}\n\ninterface MessageDeltaEvent {\n  type: 'message_delta';\n  delta: {\n    stop_reason: string;\n    stop_sequence: string | null;\n  };\n  usage: {\n    output_tokens: number;\n  };\n}\n\n// Helper to convert Zod schema to Anthropic-compatible JSON Schema\nfunction zodToAnthropicSchema(schema: z.ZodSchema): JSONSchemaType {\n  // Handle both Zod v3 and v4 structure\n  const zodType = schema._def || (schema as z.ZodTypeAny & { def?: unknown }).def;\n\n  if (!zodType) {\n    throw new Error('Invalid Zod schema: missing _def property');\n  }\n\n  function processZodType(def: any): JSONSchemaType {\n    switch (def.type) {\n      case 'string':\n        return { type: 'string' };\n      case 'number':\n        return { type: 'number' };\n      case 'boolean':\n        return { type: 'boolean' };\n      case 'array': {\n        const itemDef =\n          def.valueType?._def ||\n          def.valueType?.def ||\n          def.valueType ||\n          def.element?._def ||\n          def.element?.def ||\n          def.element;\n        return {\n          type: 'array',\n          items: itemDef ? processZodType(itemDef) : { type: 'any' },\n        };\n      }\n      case 'object': {\n        const properties: Record<string, JSONSchemaType> = {};\n        const required: string[] = [];\n\n        // Access shape directly from def\n        const shape = def.shape || {};\n        for (const [key, value] of Object.entries(shape)) {\n          // Handle both Zod v3 and v4 - in v4, each field has its own _def\n          const fieldDef = (value as any)._def || (value as any).def || value;\n          const fieldSchema = processZodType(fieldDef);\n          properties[key] = fieldSchema;\n\n          // Check if field is optional\n          if (fieldDef.type !== 'optional') {\n            required.push(key);\n          }\n        }\n\n        return {\n          type: 'object',\n          properties,\n          required: required.length > 0 ? required : undefined,\n        };\n      }\n      case 'optional': {\n        const innerDef =\n          (def as any).innerType?._def || (def as any).innerType?.def || (def as any).innerType;\n        return innerDef ? processZodType(innerDef) : { type: 'any' };\n      }\n      case 'enum':\n        return {\n          type: 'string',\n          enum: (def as any).values || [],\n        };\n      case 'literal':\n        return {\n          type: typeof def.value,\n          const: (def as any).value,\n        };\n      default:\n        // Fallback for unsupported types\n        return { type: 'string' };\n    }\n  }\n\n  return processZodType(zodType);\n}\n\nexport class AnthropicProvider implements TypedProvider<'anthropic'> {\n  readonly name = 'anthropic' as const;\n  readonly capabilities: ProviderCapabilities = {\n    streaming: true,\n    tools: true,\n    structuredOutput: true,\n    vision: true,\n    maxTokens: 200000, // Claude 3 supports up to 200k tokens\n  };\n\n  private apiKey: string;\n  private baseURL = 'https://api.anthropic.com/v1';\n  private apiVersion = '2023-06-01';\n  private retryConfig?: RetryConfig;\n\n  constructor(apiKey: string, baseURL?: string, retryConfig?: RetryConfig) {\n    this.apiKey = apiKey;\n    if (baseURL) {\n      this.baseURL = baseURL.replace(/\\/$/, ''); // Remove trailing slash\n    }\n    this.retryConfig = retryConfig;\n  }\n\n  async chat<T = string>(\n    request: ProviderChatRequest<'anthropic'>,\n  ): Promise<ProviderChatResponse<'anthropic', T>> {\n    const makeRequest = async () => {\n      const anthropicRequest = this.transformRequest(request);\n      const response = await fetch(`${this.baseURL}/messages`, {\n        method: 'POST',\n        headers: {\n          'x-api-key': this.apiKey,\n          'anthropic-version': this.apiVersion,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(anthropicRequest),\n      });\n\n      if (!response) {\n        throw new LLMError(\n          'Network error: No response received',\n          undefined,\n          'anthropic',\n          request.model,\n        );\n      }\n\n      if (!response.ok) {\n        const error = (await response\n          .json()\n          .catch(() => ({ error: { message: response.statusText } }))) as {\n          error?: { message?: string };\n        };\n\n        const retryAfter = response.headers.get('Retry-After');\n        const errorMessage = `Anthropic API error (${response.status}): ${error.error?.message || 'Unknown error'}`;\n        const llmError = new LLMError(errorMessage, response.status, 'anthropic', request.model);\n        if (retryAfter) {\n          llmError.retryAfter = parseInt(retryAfter, 10);\n        }\n        throw llmError;\n      }\n\n      const data = (await response.json()) as AnthropicResponse;\n      return this.transformResponse<T>(data, request.schema);\n    };\n\n    if (this.retryConfig) {\n      return retry(makeRequest, this.retryConfig);\n    }\n\n    return makeRequest();\n  }\n\n  async stream<T = string>(\n    request: ProviderChatRequest<'anthropic'>,\n  ): Promise<StreamingResponse<T>> {\n    const anthropicRequest = this.transformRequest(request);\n    anthropicRequest.stream = true;\n\n    const response = await fetch(`${this.baseURL}/messages`, {\n      method: 'POST',\n      headers: {\n        'x-api-key': this.apiKey,\n        'anthropic-version': this.apiVersion,\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(anthropicRequest),\n    });\n\n    if (!response.ok) {\n      const error = (await response\n        .json()\n        .catch(() => ({ error: { message: response.statusText } }))) as {\n        error?: { message?: string };\n      };\n      throw new Error(\n        `Anthropic API error (${response.status}): ${error.error?.message || 'Unknown error'}`,\n      );\n    }\n\n    const reader = response.body!.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n    let content = '';\n    let usage = { input_tokens: 0, output_tokens: 0 };\n    let model = '';\n    let anthropicFinishReason: string | undefined;\n    let currentToolUse: { id: string; name: string; input?: unknown } | null = null;\n    let toolUseInput = '';\n    // let messageId = ''; // Not needed since id is not part of response type\n\n    const streamResponse = {\n      async *[Symbol.asyncIterator](): AsyncIterator<T> {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || '';\n\n          for (const line of lines) {\n            if (line.startsWith('event: ')) {\n              // We don't need the event type for now\n              continue;\n            }\n\n            if (line.startsWith('data: ')) {\n              const data = line.slice(6);\n              if (!data || data === '[DONE]') continue;\n\n              try {\n                const event = JSON.parse(data);\n\n                switch (event.type) {\n                  case 'message_start': {\n                    const msgStart = event as MessageStartEvent;\n                    // messageId = msgStart.message.id;\n                    model = msgStart.message.model;\n                    usage.input_tokens = msgStart.message.usage.input_tokens;\n                    break;\n                  }\n\n                  case 'content_block_delta': {\n                    const delta = event as ContentBlockDeltaEvent;\n                    if (delta.delta.type === 'text_delta') {\n                      const text = delta.delta.text;\n                      content += text;\n                      // For structured output, we can't yield partial JSON\n                      if (!request.schema) {\n                        yield text as T;\n                      }\n                    } else if (event.delta?.type === 'input_json_delta' && currentToolUse) {\n                      toolUseInput += event.delta.partial_json;\n                    }\n                    break;\n                  }\n\n                  case 'message_delta': {\n                    const msgDelta = event as MessageDeltaEvent;\n                    usage.output_tokens = msgDelta.usage.output_tokens;\n                    anthropicFinishReason = msgDelta.delta.stop_reason;\n                    break;\n                  }\n\n                  case 'content_block_start': {\n                    if (event.content_block?.type === 'tool_use') {\n                      currentToolUse = event.content_block;\n                      toolUseInput = '';\n                    }\n                    break;\n                  }\n\n                  // Duplicate case removed - handled in first content_block_delta case\n                }\n              } catch {\n                // Ignore parsing errors\n              }\n            }\n          }\n        }\n      },\n\n      async complete(): Promise<ProviderChatResponse<'anthropic', T>> {\n        // Drain any remaining content\n        for await (const _chunk of streamResponse) {\n          // Just consume\n        }\n\n        let parsedContent: T;\n\n        // If we used schema-based tool calling, extract from tool call\n        if (\n          request.schema &&\n          currentToolUse?.name === 'respond_with_structured_output' &&\n          toolUseInput\n        ) {\n          try {\n            const parsed = JSON.parse(toolUseInput);\n            parsedContent = request.schema.parse(parsed) as T;\n          } catch {\n            parsedContent = content as T;\n          }\n        } else if (request.schema && content) {\n          try {\n            const parsed = JSON.parse(content);\n            parsedContent = request.schema.parse(parsed) as T;\n          } catch {\n            parsedContent = content as T;\n          }\n        } else {\n          parsedContent = content as T;\n        }\n\n        // Map Anthropic finish reasons to standard ones\n        let finishReason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | undefined;\n        if (anthropicFinishReason) {\n          if (anthropicFinishReason === 'end_turn' || anthropicFinishReason === 'stop_sequence') {\n            finishReason = 'stop';\n          } else if (anthropicFinishReason === 'max_tokens') {\n            finishReason = 'length';\n          } else if (anthropicFinishReason === 'tool_use') {\n            finishReason = 'tool_calls';\n          }\n        }\n\n        return {\n          content: parsedContent,\n          usage: {\n            inputTokens: usage.input_tokens,\n            outputTokens: usage.output_tokens,\n            totalTokens: usage.input_tokens + usage.output_tokens,\n          },\n          model,\n          finishReason,\n          // id: messageId // Not part of the response type\n        };\n      },\n    };\n\n    return streamResponse;\n  }\n\n  supportsFeature(feature: string): boolean {\n    return (\n      feature in this.capabilities &&\n      (this.capabilities as unknown as Record<string, boolean>)[feature] === true\n    );\n  }\n\n  private transformRequest(request: ProviderChatRequest<'anthropic'>): AnthropicRequest {\n    // Extract system message if present\n    let system: string | undefined;\n    const messages: AnthropicMessage[] = [];\n\n    for (const msg of request.messages) {\n      if (msg.role === 'system') {\n        system = typeof msg.content === 'string' ? msg.content : '';\n      } else {\n        messages.push(this.transformMessage(msg));\n      }\n    }\n\n    const anthropicRequest: AnthropicRequest = {\n      model: request.model || 'claude-3-opus-20240229', // Default fallback\n      messages,\n      system,\n      max_tokens: request.maxTokens || 4096,\n      temperature: request.temperature,\n    };\n\n    // Handle structured output via schema using forced tool calling\n    if (request.schema && !request.tools) {\n      // Create a hidden tool for structured output\n      const jsonSchema = zodToAnthropicSchema(request.schema);\n      anthropicRequest.tools = [\n        {\n          name: 'respond_with_structured_output',\n          description: 'Respond with structured data matching the required schema',\n          input_schema: jsonSchema,\n        },\n      ];\n      // Force the model to use this specific tool\n      anthropicRequest.tool_choice = { type: 'tool', name: 'respond_with_structured_output' };\n    }\n\n    // Handle Anthropic-specific features\n    if (request.features) {\n      if (request.features.thinking && request.features.maxThinkingTokens) {\n        anthropicRequest.max_thinking_tokens = request.features.maxThinkingTokens;\n      }\n      // cacheControl would be handled here when implemented\n    }\n\n    // Handle tools\n    if (request.tools) {\n      anthropicRequest.tools = request.tools.map((tool) => ({\n        name: tool.name,\n        description: tool.description,\n        input_schema: tool.parameters\n          ? zodToAnthropicSchema(tool.parameters)\n          : { type: 'object', properties: {} },\n      }));\n    }\n\n    if (request.toolChoice === 'required' && request.tools?.length !== 1) {\n      throw new Error('Only 1 tool can be provided when using toolChoice: required');\n    }\n\n    // Handle tool choice\n    if (request.toolChoice) {\n      switch (request.toolChoice) {\n        case 'required': {\n          anthropicRequest.tool_choice = { type: 'tool', name: request.tools?.[0]?.name };\n\n          break;\n        }\n        case 'none': {\n          // Don't include tools if none\n          delete anthropicRequest.tools;\n\n          break;\n        }\n        case 'auto': {\n          anthropicRequest.tool_choice = { type: 'auto' };\n\n          break;\n        }\n        default:\n          if (typeof request.toolChoice === 'object' && 'name' in request.toolChoice) {\n            anthropicRequest.tool_choice = {\n              type: 'tool',\n              name: request.toolChoice.name,\n            };\n          }\n      }\n    }\n\n    return anthropicRequest;\n  }\n\n  private transformMessage(message: Message): AnthropicMessage {\n    if (typeof message.content === 'string') {\n      return {\n        role: message.role as 'user' | 'assistant',\n        content: message.content,\n      };\n    }\n\n    // Handle multi-modal content\n    const anthropicContent: AnthropicContent[] = message.content.map((c) => {\n      if (c.type === 'text') {\n        return { type: 'text' as const, text: c.text || '' };\n      }\n      // Handle image content if needed\n      return { type: 'text' as const, text: '[Image content]' };\n    });\n\n    return {\n      role: message.role as 'user' | 'assistant',\n      content: anthropicContent,\n    };\n  }\n\n  private transformResponse<T>(\n    response: AnthropicResponse,\n    schema?: z.ZodSchema,\n  ): ProviderChatResponse<'anthropic', T> {\n    let content = '';\n    let thinking = '';\n    const toolCalls: ToolCall[] = [];\n\n    // Process content blocks\n    for (const block of response.content) {\n      switch (block.type) {\n        case 'text': {\n          content += block.text;\n\n          break;\n        }\n        case 'thinking': {\n          thinking += block.text;\n\n          break;\n        }\n        case 'tool_use': {\n          toolCalls.push({\n            id: block.id,\n            name: block.name,\n            arguments: block.input,\n          });\n\n          break;\n        }\n        // No default\n      }\n    }\n\n    let parsedContent: T;\n\n    // If we used schema-based tool calling, extract the structured data from tool call\n    const structuredOutputTool = toolCalls.find(\n      (tc) => tc.name === 'respond_with_structured_output',\n    );\n    if (schema && structuredOutputTool) {\n      try {\n        parsedContent = schema.parse(structuredOutputTool.arguments) as T;\n      } catch {\n        parsedContent = content as T;\n      }\n    } else if (schema && content) {\n      try {\n        const parsed = JSON.parse(content);\n        parsedContent = schema.parse(parsed) as T;\n      } catch {\n        parsedContent = content as T;\n      }\n    } else {\n      parsedContent = content as T;\n    }\n\n    const totalTokens =\n      response.usage.input_tokens +\n      response.usage.output_tokens +\n      (response.usage.thinking_tokens || 0);\n\n    const result: ProviderChatResponse<'anthropic', T> = {\n      content: parsedContent,\n      usage: {\n        inputTokens: response.usage.input_tokens,\n        outputTokens: response.usage.output_tokens,\n        totalTokens: totalTokens,\n      },\n      model: response.model,\n      finishReason: response.stop_reason as any,\n      // id: response.id // Not part of the response type\n    };\n\n    // Only include tool calls if not using schema-based tool calling\n    // or if there are other tool calls besides the structured output tool\n    const nonStructuredToolCalls = toolCalls.filter(\n      (tc) => tc.name !== 'respond_with_structured_output',\n    );\n    if (nonStructuredToolCalls.length > 0 && !schema) {\n      result.toolCalls = nonStructuredToolCalls;\n    }\n\n    if (thinking) {\n      result.thinking = thinking;\n    }\n\n    return result;\n  }\n\n  async listModels(): Promise<ModelInfo[]> {\n    const response = await fetch(`${this.baseURL}/models`, {\n      method: 'GET',\n      headers: {\n        'x-api-key': this.apiKey,\n        'anthropic-version': this.apiVersion,\n      },\n    });\n\n    if (!response.ok) {\n      const error = (await response\n        .json()\n        .catch(() => ({ error: { message: response.statusText } }))) as {\n        error?: { message?: string };\n      };\n      throw new LLMError(\n        `Anthropic API error (${response.status}): ${error.error?.message || 'Unknown error'}`,\n        response.status,\n        'anthropic',\n      );\n    }\n\n    const data = (await response.json()) as {\n      data: Array<{\n        id: string;\n        display_name: string;\n        created_at: string;\n      }>;\n    };\n\n    return data.data.map((model) => ({\n      id: model.id,\n      name: model.display_name || model.id,\n      created: new Date(model.created_at).getTime() / 1000,\n    }));\n  }\n}\n"]}