{"version":3,"file":"openai.js","sourceRoot":"","sources":["../../../src/providers/openai/openai.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,CAAC,EAAE,MAAM,KAAK,CAAC;AAIxB,OAAO,EAAE,KAAK,EAAE,MAAM,aAAa,CAAC;AACpC,OAAO,EAAE,QAAQ,EAAE,MAAM,oBAAoB,CAAC;AAoH9C,gEAAgE;AAChE,SAAS,iBAAiB,CAAC,MAAmB;IAC5C,sCAAsC;IACtC,MAAM,OAAO,GAAG,MAAM,CAAC,IAAI,IAAK,MAA2C,CAAC,GAAG,CAAC;IAEhF,IAAI,CAAC,OAAO,EAAE,CAAC;QACb,MAAM,IAAI,KAAK,CAAC,2CAA2C,CAAC,CAAC;IAC/D,CAAC;IAED,SAAS,cAAc,CAAC,GAAQ;QAC9B,QAAQ,GAAG,CAAC,IAAI,EAAE,CAAC;YACjB,KAAK,QAAQ;gBACX,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC;YAC5B,KAAK,QAAQ;gBACX,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC;YAC5B,KAAK,SAAS;gBACZ,OAAO,EAAE,IAAI,EAAE,SAAS,EAAE,CAAC;YAC7B,KAAK,OAAO,CAAC,CAAC,CAAC;gBACb,MAAM,OAAO,GACX,GAAG,CAAC,SAAS,EAAE,IAAI;oBACnB,GAAG,CAAC,SAAS,EAAE,GAAG;oBAClB,GAAG,CAAC,SAAS;oBACb,GAAG,CAAC,OAAO,EAAE,IAAI;oBACjB,GAAG,CAAC,OAAO,EAAE,GAAG;oBAChB,GAAG,CAAC,OAAO,CAAC;gBACd,OAAO;oBACL,IAAI,EAAE,OAAO;oBACb,KAAK,EAAE,OAAO,CAAC,CAAC,CAAC,cAAc,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE;iBAC9D,CAAC;YACJ,CAAC;YACD,KAAK,QAAQ,CAAC,CAAC,CAAC;gBACd,MAAM,UAAU,GAAmC,EAAE,CAAC;gBACtD,MAAM,QAAQ,GAAa,EAAE,CAAC;gBAE9B,iCAAiC;gBACjC,MAAM,KAAK,GAAG,GAAG,CAAC,KAAK,IAAI,EAAE,CAAC;gBAC9B,KAAK,MAAM,CAAC,GAAG,EAAE,KAAK,CAAC,IAAI,MAAM,CAAC,OAAO,CAAC,KAAK,CAAC,EAAE,CAAC;oBACjD,iEAAiE;oBACjE,MAAM,QAAQ,GACX,KAAsB,CAAC,IAAI;wBAC3B,KAA0C,CAAC,GAAG;wBAC/C,KAAK,CAAC;oBACR,MAAM,WAAW,GAAG,cAAc,CAAC,QAAQ,CAAC,CAAC;oBAC7C,yEAAyE;oBACzE,+CAA+C;oBAC/C,OAAO,WAAW,CAAC,YAAY,CAAC;oBAChC,UAAU,CAAC,GAAG,CAAC,GAAG,WAAW,CAAC;oBAE9B,6EAA6E;oBAC7E,8DAA8D;oBAC9D,QAAQ,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;gBACrB,CAAC;gBAED,OAAO;oBACL,IAAI,EAAE,QAAQ;oBACd,UAAU;oBACV,QAAQ,EAAE,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,SAAS;oBACpD,oBAAoB,EAAE,KAAK;iBAC5B,CAAC;YACJ,CAAC;YACD,KAAK,UAAU,CAAC,CAAC,CAAC;gBAChB,4DAA4D;gBAC5D,oDAAoD;gBACpD,MAAM,QAAQ,GAAG,GAAG,CAAC,SAAS,EAAE,IAAI,IAAI,GAAG,CAAC,SAAS,EAAE,GAAG,IAAI,GAAG,CAAC,SAAS,CAAC;gBAC5E,MAAM,SAAS,GAAG,QAAQ,CAAC,CAAC,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC;gBAC3E,OAAO,EAAE,GAAG,SAAS,EAAE,YAAY,EAAE,IAAI,EAAE,CAAC;YAC9C,CAAC;YACD,KAAK,MAAM;gBACT,OAAO;oBACL,IAAI,EAAE,QAAQ;oBACd,IAAI,EAAE,GAAG,CAAC,MAAM;iBACjB,CAAC;YACJ,KAAK,SAAS;gBACZ,OAAO;oBACL,IAAI,EAAE,OAAO,GAAG,CAAC,KAAK;oBACtB,KAAK,EAAE,GAAG,CAAC,KAAK;iBACjB,CAAC;YACJ;gBACE,iCAAiC;gBACjC,OAAO,EAAE,IAAI,EAAE,QAAQ,EAAE,CAAC;QAC9B,CAAC;IACH,CAAC;IAED,OAAO,cAAc,CAAC,OAAO,CAAC,CAAC;AACjC,CAAC;AAED,MAAM,OAAO,cAAc;IAczB,YAAY,MAAc,EAAE,OAAgB,EAAE,WAAyB;QAb9D,SAAI,GAAG,QAAiB,CAAC;QACzB,iBAAY,GAAyB;YAC5C,SAAS,EAAE,IAAI;YACf,KAAK,EAAE,IAAI;YACX,gBAAgB,EAAE,IAAI;YACtB,MAAM,EAAE,IAAI;YACZ,SAAS,EAAE,MAAM;SAClB,CAAC;QAGM,YAAO,GAAG,2BAA2B,CAAC;QAI5C,IAAI,CAAC,MAAM,GAAG,MAAM,CAAC;QACrB,IAAI,OAAO,EAAE,CAAC;YACZ,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,OAAO,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC,CAAC,wBAAwB;QACrE,CAAC;QACD,IAAI,CAAC,WAAW,GAAG,WAAW,CAAC;IACjC,CAAC;IAED,KAAK,CAAC,IAAI,CACR,OAAsC;QAEtC,MAAM,WAAW,GAAG,KAAK,IAAI,EAAE;YAC7B,MAAM,aAAa,GAAG,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;YAErD,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,GAAG,IAAI,CAAC,OAAO,mBAAmB,EAAE;gBAC/D,MAAM,EAAE,MAAM;gBACd,OAAO,EAAE;oBACP,eAAe,EAAE,UAAU,IAAI,CAAC,MAAM,EAAE;oBACxC,cAAc,EAAE,kBAAkB;iBACnC;gBACD,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC;aACpC,CAAC,CAAC;YAEH,IAAI,CAAC,QAAQ,EAAE,CAAC;gBACd,MAAM,IAAI,QAAQ,CAChB,qCAAqC,EACrC,SAAS,EACT,QAAQ,EACR,OAAO,CAAC,KAAK,CACd,CAAC;YACJ,CAAC;YAED,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;gBACjB,MAAM,KAAK,GAAG,CAAC,MAAM,QAAQ;qBAC1B,IAAI,EAAE;qBACN,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,OAAO,EAAE,QAAQ,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC,CAE5D,CAAC;gBAEF,wCAAwC;gBACxC,MAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;gBACvD,MAAM,YAAY,GAAG,qBAAqB,QAAQ,CAAC,MAAM,MAAM,KAAK,CAAC,KAAK,EAAE,OAAO,IAAI,eAAe,EAAE,CAAC;gBACzG,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAAC,YAAY,EAAE,QAAQ,CAAC,MAAM,EAAE,QAAQ,EAAE,OAAO,CAAC,KAAK,CAAC,CAAC;gBACtF,IAAI,UAAU,EAAE,CAAC;oBACf,QAAQ,CAAC,UAAU,GAAG,QAAQ,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;gBACjD,CAAC;gBACD,MAAM,QAAQ,CAAC;YACjB,CAAC;YAED,MAAM,IAAI,GAAG,CAAC,MAAM,QAAQ,CAAC,IAAI,EAAE,CAAmB,CAAC;YACvD,OAAO,IAAI,CAAC,iBAAiB,CAAI,IAAI,EAAE,OAAO,CAAC,MAAM,CAAC,CAAC;QACzD,CAAC,CAAC;QAEF,0CAA0C;QAC1C,IAAI,IAAI,CAAC,WAAW,EAAE,CAAC;YACrB,OAAO,KAAK,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC;QAC9C,CAAC;QAED,OAAO,WAAW,EAAE,CAAC;IACvB,CAAC;IAED,KAAK,CAAC,MAAM,CAAa,OAAsC;QAC7D,MAAM,WAAW,GAAG,KAAK,IAAuB,EAAE;YAChD,MAAM,aAAa,GAAG,IAAI,CAAC,gBAAgB,CAAC,OAAO,CAAC,CAAC;YACrD,aAAa,CAAC,MAAM,GAAG,IAAI,CAAC;YAC5B,aAAa,CAAC,cAAc,GAAG,EAAE,aAAa,EAAE,IAAI,EAAE,CAAC;YAEvD,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,GAAG,IAAI,CAAC,OAAO,mBAAmB,EAAE;gBAC/D,MAAM,EAAE,MAAM;gBACd,OAAO,EAAE;oBACP,eAAe,EAAE,UAAU,IAAI,CAAC,MAAM,EAAE;oBACxC,cAAc,EAAE,kBAAkB;iBACnC;gBACD,IAAI,EAAE,IAAI,CAAC,SAAS,CAAC,aAAa,CAAC;aACpC,CAAC,CAAC;YAEH,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;gBACjB,MAAM,KAAK,GAAG,CAAC,MAAM,QAAQ;qBAC1B,IAAI,EAAE;qBACN,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,OAAO,EAAE,QAAQ,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC,CAE5D,CAAC;gBAEF,MAAM,UAAU,GAAG,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC;gBACvD,MAAM,QAAQ,GAAG,IAAI,QAAQ,CAC3B,KAAK,CAAC,KAAK,EAAE,OAAO,IAAI,eAAe,EACvC,QAAQ,CAAC,MAAM,EACf,QAAQ,EACR,OAAO,CAAC,KAAK,CACd,CAAC;gBACF,IAAI,UAAU,EAAE,CAAC;oBACf,QAAQ,CAAC,UAAU,GAAG,QAAQ,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC;gBACjD,CAAC;gBACD,MAAM,QAAQ,CAAC;YACjB,CAAC;YAED,OAAO,QAAQ,CAAC;QAClB,CAAC,CAAC;QAEF,kCAAkC;QAClC,MAAM,QAAQ,GAAG,IAAI,CAAC,WAAW;YAC/B,CAAC,CAAC,MAAM,KAAK,CAAC,WAAW,EAAE,IAAI,CAAC,WAAW,CAAC;YAC5C,CAAC,CAAC,MAAM,WAAW,EAAE,CAAC;QAExB,MAAM,MAAM,GAAG,QAAQ,CAAC,IAAK,CAAC,SAAS,EAAE,CAAC;QAC1C,MAAM,OAAO,GAAG,IAAI,WAAW,EAAE,CAAC;QAClC,IAAI,MAAM,GAAG,EAAE,CAAC;QAChB,IAAI,OAAO,GAAG,EAAE,CAAC;QACjB,IAAI,KAAK,GAAkF,EAAE,CAAC;QAC9F,IAAI,KAAK,GAAG,EAAE,CAAC;QACf,IAAI,YAA6E,CAAC;QAClF,IAAI,iBAAiB,GAAG,EAAE,CAAC;QAC3B,IAAI,eAAe,GAIR,IAAI,CAAC;QAEhB,MAAM,cAAc,GAAG;YACrB,KAAK,CAAC,CAAC,CAAC,MAAM,CAAC,aAAa,CAAC;gBAC3B,OAAO,IAAI,EAAE,CAAC;oBACZ,MAAM,EAAE,IAAI,EAAE,KAAK,EAAE,GAAG,MAAM,MAAM,CAAC,IAAI,EAAE,CAAC;oBAC5C,IAAI,IAAI;wBAAE,MAAM;oBAEhB,MAAM,IAAI,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,EAAE,MAAM,EAAE,IAAI,EAAE,CAAC,CAAC;oBAClD,MAAM,KAAK,GAAG,MAAM,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;oBACjC,MAAM,GAAG,KAAK,CAAC,GAAG,EAAE,IAAI,EAAE,CAAC;oBAE3B,KAAK,MAAM,IAAI,IAAI,KAAK,EAAE,CAAC;wBACzB,IAAI,IAAI,CAAC,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC;4BAC9B,MAAM,IAAI,GAAG,IAAI,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC;4BAC3B,IAAI,IAAI,KAAK,QAAQ;gCAAE,SAAS;4BAEhC,IAAI,CAAC;gCACH,MAAM,KAAK,GAAsB,IAAI,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC;gCAClD,KAAK,GAAG,KAAK,CAAC,KAAK,CAAC;gCAEpB,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,OAAO,EAAE,CAAC;oCACrC,MAAM,YAAY,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC;oCACpD,OAAO,IAAI,YAAY,CAAC;oCACxB,qDAAqD;oCACrD,sCAAsC;oCACtC,IAAI,CAAC,OAAO,CAAC,MAAM,EAAE,CAAC;wCACpB,MAAM,YAAiB,CAAC;oCAC1B,CAAC;gCACH,CAAC;gCAED,6BAA6B;gCAC7B,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,KAAK,EAAE,UAAU,EAAE,CAAC;oCACxC,KAAK,MAAM,aAAa,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,KAAK,CAAC,UAAU,EAAE,CAAC;wCAC9D,IAAI,aAAa,CAAC,EAAE,EAAE,CAAC;4CACrB,eAAe,GAAG;gDAChB,EAAE,EAAE,aAAa,CAAC,EAAG;gDACrB,IAAI,EAAE,UAAmB;gDACzB,QAAQ,EAAE;oDACR,IAAI,EAAE,aAAa,CAAC,QAAQ,EAAE,IAAI,IAAI,EAAE;oDACxC,SAAS,EAAE,EAAE;iDACd;6CACF,CAAC;4CACF,iBAAiB,GAAG,EAAE,CAAC;wCACzB,CAAC;wCACD,IAAI,aAAa,CAAC,QAAQ,EAAE,SAAS,EAAE,CAAC;4CACtC,iBAAiB,IAAI,aAAa,CAAC,QAAQ,CAAC,SAAS,CAAC;wCACxD,CAAC;oCACH,CAAC;gCACH,CAAC;gCAED,IAAI,KAAK,CAAC,KAAK,EAAE,CAAC;oCAChB,KAAK,GAAG;wCACN,aAAa,EAAE,KAAK,CAAC,KAAK,CAAC,aAAa;wCACxC,iBAAiB,EAAE,KAAK,CAAC,KAAK,CAAC,iBAAiB;wCAChD,YAAY,EAAE,KAAK,CAAC,KAAK,CAAC,YAAY;qCACvC,CAAC;gCACJ,CAAC;gCAED,IAAI,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,EAAE,aAAa,EAAE,CAAC;oCACpC,YAAY,GAAG,KAAK,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,aAAa,CAAC;gCAChD,CAAC;4BACH,CAAC;4BAAC,MAAM,CAAC;gCACP,wBAAwB;4BAC1B,CAAC;wBACH,CAAC;oBACH,CAAC;gBACH,CAAC;YACH,CAAC;YAED,KAAK,CAAC,QAAQ;gBACZ,8BAA8B;gBAC9B,IAAI,KAAK,EAAE,MAAM,MAAM,IAAI,cAAc,EAAE,CAAC;oBAC1C,eAAe;gBACjB,CAAC;gBAED,IAAI,aAAgB,CAAC;gBAErB,+DAA+D;gBAC/D,IACE,OAAO,CAAC,MAAM;oBACd,iBAAiB;oBACjB,eAAe,EAAE,QAAQ,EAAE,IAAI,KAAK,gCAAgC,EACpE,CAAC;oBACD,IAAI,CAAC;wBACH,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,iBAAiB,CAAC,CAAC;wBAC7C,aAAa,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAM,CAAC;oBACpD,CAAC;oBAAC,MAAM,CAAC;wBACP,aAAa,GAAG,OAAY,CAAC;oBAC/B,CAAC;gBACH,CAAC;qBAAM,IAAI,OAAO,CAAC,MAAM,IAAI,OAAO,EAAE,CAAC;oBACrC,IAAI,CAAC;wBACH,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;wBACnC,aAAa,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,CAAC,MAAM,CAAM,CAAC;oBACpD,CAAC;oBAAC,MAAM,CAAC;wBACP,aAAa,GAAG,OAAY,CAAC;oBAC/B,CAAC;gBACH,CAAC;qBAAM,CAAC;oBACN,aAAa,GAAG,OAAY,CAAC;gBAC/B,CAAC;gBAED,OAAO;oBACL,OAAO,EAAE,aAAa;oBACtB,KAAK,EAAE;wBACL,WAAW,EAAE,KAAK,CAAC,aAAa,IAAI,CAAC;wBACrC,YAAY,EAAE,KAAK,CAAC,iBAAiB,IAAI,CAAC;wBAC1C,WAAW,EAAE,KAAK,CAAC,YAAY,IAAI,CAAC;qBACrC;oBACD,KAAK;oBACL,YAAY;iBACb,CAAC;YACJ,CAAC;SACF,CAAC;QAEF,OAAO,cAAc,CAAC;IACxB,CAAC;IAED,eAAe,CAAC,OAAe;QAC7B,OAAO,CACL,OAAO,IAAI,IAAI,CAAC,YAAY;YAC3B,IAAI,CAAC,YAAmD,CAAC,OAAO,CAAC,KAAK,IAAI,CAC5E,CAAC;IACJ,CAAC;IAEO,gBAAgB,CAAC,OAAsC;QAC7D,MAAM,aAAa,GAAkB;YACnC,KAAK,EAAE,OAAO,CAAC,KAAK,IAAI,aAAa,EAAE,mBAAmB;YAC1D,QAAQ,EAAE,OAAO,CAAC,QAAQ,CAAC,GAAG,CAAC,IAAI,CAAC,gBAAgB,CAAC;YACrD,WAAW,EAAE,OAAO,CAAC,WAAW;YAChC,UAAU,EAAE,OAAO,CAAC,SAAS;SAC9B,CAAC;QAEF,kCAAkC;QAClC,IAAI,OAAO,CAAC,QAAQ,EAAE,CAAC;YACrB,IAAI,OAAO,CAAC,QAAQ,CAAC,QAAQ,KAAK,SAAS,EAAE,CAAC;gBAC5C,aAAa,CAAC,QAAQ,GAAG,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC;YACrD,CAAC;YACD,IAAI,OAAO,CAAC,QAAQ,CAAC,WAAW,KAAK,SAAS,EAAE,CAAC;gBAC/C,aAAa,CAAC,YAAY,GAAG,OAAO,CAAC,QAAQ,CAAC,WAAW,CAAC;YAC5D,CAAC;YACD,IAAI,OAAO,CAAC,QAAQ,CAAC,IAAI,KAAK,SAAS,EAAE,CAAC;gBACxC,aAAa,CAAC,IAAI,GAAG,OAAO,CAAC,QAAQ,CAAC,IAAI,CAAC;YAC7C,CAAC;YACD,IAAI,OAAO,CAAC,QAAQ,CAAC,cAAc,KAAK,SAAS,EAAE,CAAC;gBAClD,aAAa,CAAC,eAAe,GAAG,OAAO,CAAC,QAAQ,CAAC,cAGhD,CAAC;YACJ,CAAC;QACH,CAAC;QAED,gEAAgE;QAChE,IAAI,OAAO,CAAC,MAAM,IAAI,CAAC,OAAO,CAAC,KAAK,EAAE,CAAC;YACrC,6CAA6C;YAC7C,MAAM,UAAU,GAAG,iBAAiB,CAAC,OAAO,CAAC,MAAM,CAAC,CAAC;YACrD,aAAa,CAAC,KAAK,GAAG;gBACpB;oBACE,IAAI,EAAE,UAAmB;oBACzB,QAAQ,EAAE;wBACR,IAAI,EAAE,gCAAgC;wBACtC,WAAW,EAAE,2DAA2D;wBACxE,UAAU,EAAE,UAAU;wBACtB,MAAM,EAAE,IAAI;qBACb;iBACF;aACF,CAAC;YACF,mCAAmC;YACnC,aAAa,CAAC,WAAW,GAAG,UAAU,CAAC;QACzC,CAAC;QAED,eAAe;QACf,IAAI,OAAO,CAAC,KAAK,EAAE,CAAC;YAClB,aAAa,CAAC,KAAK,GAAG,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,EAAE,CAAC,CAAC;gBACjD,IAAI,EAAE,UAAmB;gBACzB,QAAQ,EAAE;oBACR,IAAI,EAAE,IAAI,CAAC,IAAI;oBACf,WAAW,EAAE,IAAI,CAAC,WAAW;oBAC7B,UAAU,EAAE,iBAAiB,CAAC,IAAI,CAAC,UAAU,CAAC;oBAC9C,MAAM,EAAE,IAAI;iBACb;aACF,CAAC,CAAC,CAAC;QACN,CAAC;QAED,qBAAqB;QACrB,IAAI,OAAO,CAAC,UAAU,EAAE,CAAC;YACvB,QAAQ,OAAO,CAAC,UAAU,EAAE,CAAC;gBAC3B,KAAK,UAAU,CAAC,CAAC,CAAC;oBAChB,aAAa,CAAC,WAAW,GAAG,UAAU,CAAC;oBAEvC,MAAM;gBACR,CAAC;gBACD,KAAK,MAAM,CAAC,CAAC,CAAC;oBACZ,aAAa,CAAC,WAAW,GAAG,MAAM,CAAC;oBAEnC,MAAM;gBACR,CAAC;gBACD,KAAK,MAAM,CAAC,CAAC,CAAC;oBACZ,aAAa,CAAC,WAAW,GAAG,MAAM,CAAC;oBAEnC,MAAM;gBACR,CAAC;gBACD;oBACE,IAAI,OAAO,OAAO,CAAC,UAAU,KAAK,QAAQ,IAAI,MAAM,IAAI,OAAO,CAAC,UAAU,EAAE,CAAC;wBAC3E,aAAa,CAAC,WAAW,GAAG;4BAC1B,IAAI,EAAE,UAAU;4BAChB,QAAQ,EAAE,EAAE,IAAI,EAAE,OAAO,CAAC,UAAU,CAAC,IAAI,EAAE;yBAC5C,CAAC;oBACJ,CAAC;YACL,CAAC;QACH,CAAC;QAED,OAAO,aAAa,CAAC;IACvB,CAAC;IAEO,gBAAgB,CAAC,OAAgB;QACvC,IAAI,OAAO,OAAO,CAAC,OAAO,KAAK,QAAQ,EAAE,CAAC;YACxC,OAAO;gBACL,IAAI,EAAE,OAAO,CAAC,IAAuC;gBACrD,OAAO,EAAE,OAAO,CAAC,OAAO;aACzB,CAAC;QACJ,CAAC;QAED,6BAA6B;QAC7B,+CAA+C;QAC/C,mDAAmD;QACnD,MAAM,WAAW,GAAG,OAAO,CAAC,OAAO;aAChC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,MAAM,CAAC;aAChC,GAAG,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,CAAC;aAClB,IAAI,CAAC,IAAI,CAAC,CAAC;QAEd,OAAO;YACL,IAAI,EAAE,OAAO,CAAC,IAAW;YACzB,OAAO,EAAE,WAAW;SACrB,CAAC;IACJ,CAAC;IAEO,iBAAiB,CACvB,QAAwB,EACxB,MAAoB;QAEpB,MAAM,MAAM,GAAG,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC;QACnC,IAAI,CAAC,MAAM,EAAE,CAAC;YACZ,MAAM,IAAI,KAAK,CAAC,uBAAuB,CAAC,CAAC;QAC3C,CAAC;QACD,MAAM,OAAO,GAAG,MAAM,CAAC,OAAO,CAAC;QAE/B,IAAI,OAAU,CAAC;QAEf,mFAAmF;QACnF,IAAI,MAAM,IAAI,OAAO,CAAC,UAAU,IAAI,OAAO,CAAC,UAAU,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAClE,MAAM,QAAQ,GAAG,OAAO,CAAC,UAAU,CAAC,IAAI,CACtC,CAAC,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,QAAQ,CAAC,IAAI,KAAK,gCAAgC,CAC9D,CAAC;YACF,IAAI,QAAQ,EAAE,CAAC;gBACb,IAAI,CAAC;oBACH,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,QAAQ,CAAC,SAAS,CAAC,CAAC;oBACvD,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAM,CAAC;gBACtC,CAAC;gBAAC,MAAM,CAAC;oBACP,OAAO,GAAG,CAAC,OAAO,CAAC,OAAO,IAAI,EAAE,CAAM,CAAC;gBACzC,CAAC;YACH,CAAC;iBAAM,CAAC;gBACN,OAAO,GAAG,CAAC,OAAO,CAAC,OAAO,IAAI,EAAE,CAAM,CAAC;YACzC,CAAC;QACH,CAAC;aAAM,IAAI,MAAM,IAAI,OAAO,CAAC,OAAO,EAAE,CAAC;YACrC,IAAI,CAAC;gBACH,MAAM,MAAM,GAAG,IAAI,CAAC,KAAK,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC;gBAC3C,OAAO,GAAG,MAAM,CAAC,KAAK,CAAC,MAAM,CAAM,CAAC;YACtC,CAAC;YAAC,MAAM,CAAC;gBACP,OAAO,GAAG,OAAO,CAAC,OAAY,CAAC;YACjC,CAAC;QACH,CAAC;aAAM,CAAC;YACN,OAAO,GAAG,CAAC,OAAO,CAAC,OAAO,IAAI,EAAE,CAAM,CAAC;QACzC,CAAC;QAED,MAAM,MAAM,GAAsC;YAChD,OAAO;YACP,KAAK,EAAE;gBACL,WAAW,EAAE,QAAQ,CAAC,KAAK,CAAC,aAAa;gBACzC,YAAY,EAAE,QAAQ,CAAC,KAAK,CAAC,iBAAiB;gBAC9C,WAAW,EAAE,QAAQ,CAAC,KAAK,CAAC,YAAY;aACzC;YACD,KAAK,EAAE,QAAQ,CAAC,KAAK;YACrB,YAAY,EAAE,MAAM,CAAC,aAAa;YAClC,iBAAiB,EAAE,QAAQ,CAAC,kBAAkB;SAC/C,CAAC;QAEF,mEAAmE;QACnE,IAAI,OAAO,CAAC,UAAU,IAAI,CAAC,MAAM,EAAE,CAAC;YAClC,MAAM,CAAC,SAAS,GAAG,OAAO,CAAC,UAAU,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;gBACjD,EAAE,EAAE,EAAE,CAAC,EAAE;gBACT,IAAI,EAAE,EAAE,CAAC,QAAQ,CAAC,IAAI;gBACtB,SAAS,EAAE,IAAI,CAAC,KAAK,CAAC,EAAE,CAAC,QAAQ,CAAC,SAAS,CAAC;aAC7C,CAAC,CAAC,CAAC;QACN,CAAC;QAED,kBAAkB;QAClB,IAAI,MAAM,CAAC,QAAQ,EAAE,CAAC;YACpB,MAAM,CAAC,QAAQ,GAAG,MAAM,CAAC,QAAQ,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,CAAC;gBACrD,KAAK,EAAE,EAAE,CAAC,KAAK;gBACf,OAAO,EAAE,EAAE,CAAC,OAAO;gBACnB,WAAW,EAAE,EAAE,CAAC,YAAY;aAC7B,CAAC,CAAC,CAAC;QACN,CAAC;QAED,OAAO,MAAM,CAAC;IAChB,CAAC;IAED,KAAK,CAAC,UAAU;QACd,MAAM,QAAQ,GAAG,MAAM,KAAK,CAAC,GAAG,IAAI,CAAC,OAAO,SAAS,EAAE;YACrD,MAAM,EAAE,KAAK;YACb,OAAO,EAAE;gBACP,aAAa,EAAE,UAAU,IAAI,CAAC,MAAM,EAAE;aACvC;SACF,CAAC,CAAC;QAEH,IAAI,CAAC,QAAQ,CAAC,EAAE,EAAE,CAAC;YACjB,MAAM,KAAK,GAAG,CAAC,MAAM,QAAQ;iBAC1B,IAAI,EAAE;iBACN,KAAK,CAAC,GAAG,EAAE,CAAC,CAAC,EAAE,KAAK,EAAE,EAAE,OAAO,EAAE,QAAQ,CAAC,UAAU,EAAE,EAAE,CAAC,CAAC,CAE5D,CAAC;YACF,MAAM,IAAI,QAAQ,CAChB,qBAAqB,QAAQ,CAAC,MAAM,MAAM,KAAK,CAAC,KAAK,EAAE,OAAO,IAAI,eAAe,EAAE,EACnF,QAAQ,CAAC,MAAM,EACf,QAAQ,CACT,CAAC;QACJ,CAAC;QAED,MAAM,IAAI,GAAG,CAAC,MAAM,QAAQ,CAAC,IAAI,EAAE,CAElC,CAAC;QAEF,OAAO,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;YAC/B,EAAE,EAAE,KAAK,CAAC,EAAE;YACZ,IAAI,EAAE,KAAK,CAAC,EAAE;YACd,OAAO,EAAE,KAAK,CAAC,OAAO;SACvB,CAAC,CAAC,CAAC;IACN,CAAC;CACF","sourcesContent":["import { z } from 'zod';\nimport type { StreamingResponse, ProviderCapabilities, Message } from '../provider';\nimport type { TypedProvider, ProviderChatRequest, ProviderChatResponse, ModelInfo } from '../types';\nimport type { RetryConfig } from '../../retry/types';\nimport { retry } from '../../retry';\nimport { LLMError } from '../../retry/errors';\n\ntype JSONSchemaType = {\n  type: string;\n  properties?: Record<string, JSONSchemaType>;\n  items?: JSONSchemaType;\n  required?: string[];\n  enum?: unknown[];\n  const?: unknown;\n  additionalProperties?: boolean;\n  [key: string]: unknown;\n};\n\n// OpenAI-specific types\ninterface OpenAIMessage {\n  role: 'system' | 'user' | 'assistant';\n  content: string | null;\n  tool_calls?: Array<{\n    id: string;\n    type: 'function';\n    function: {\n      name: string;\n      arguments: string;\n    };\n  }>;\n}\n\ninterface OpenAITool {\n  type: 'function';\n  function: {\n    name: string;\n    description: string;\n    parameters: JSONSchemaType;\n    strict?: boolean;\n  };\n}\n\ninterface OpenAIRequest {\n  model: string;\n  messages: OpenAIMessage[];\n  temperature?: number;\n  max_tokens?: number;\n  top_p?: number;\n  frequency_penalty?: number;\n  presence_penalty?: number;\n  stream?: boolean;\n  stream_options?: {\n    include_usage?: boolean;\n  };\n  logprobs?: boolean;\n  top_logprobs?: number;\n  seed?: number;\n  response_format?: {\n    type: 'text' | 'json_object' | 'json_schema';\n    json_schema?: JSONSchemaType;\n  };\n  tools?: OpenAITool[];\n  tool_choice?: 'none' | 'auto' | 'required' | { type: 'function'; function: { name: string } };\n}\n\ninterface OpenAIResponse {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  system_fingerprint?: string;\n  usage: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n  choices: Array<{\n    index: number;\n    message: OpenAIMessage;\n    finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter';\n    logprobs?: {\n      content: Array<{\n        token: string;\n        logprob: number;\n        top_logprobs?: Array<{\n          token: string;\n          logprob: number;\n        }>;\n      }>;\n    };\n  }>;\n}\n\ninterface OpenAIStreamChunk {\n  id: string;\n  object: string;\n  created: number;\n  model: string;\n  choices: Array<{\n    index: number;\n    delta: {\n      content?: string;\n      tool_calls?: Array<{\n        index: number;\n        id?: string;\n        type?: 'function';\n        function?: {\n          name?: string;\n          arguments?: string;\n        };\n      }>;\n    };\n    finish_reason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | null;\n  }>;\n  usage?: {\n    prompt_tokens: number;\n    completion_tokens: number;\n    total_tokens: number;\n  };\n}\n\n// Helper to convert Zod schema to OpenAI-compatible JSON Schema\nfunction zodToOpenAISchema(schema: z.ZodSchema): JSONSchemaType {\n  // Handle both Zod v3 and v4 structure\n  const zodType = schema._def || (schema as z.ZodTypeAny & { def?: unknown }).def;\n\n  if (!zodType) {\n    throw new Error('Invalid Zod schema: missing _def property');\n  }\n\n  function processZodType(def: any): JSONSchemaType {\n    switch (def.type) {\n      case 'string':\n        return { type: 'string' };\n      case 'number':\n        return { type: 'number' };\n      case 'boolean':\n        return { type: 'boolean' };\n      case 'array': {\n        const itemDef =\n          def.valueType?._def ||\n          def.valueType?.def ||\n          def.valueType ||\n          def.element?._def ||\n          def.element?.def ||\n          def.element;\n        return {\n          type: 'array',\n          items: itemDef ? processZodType(itemDef) : { type: 'string' },\n        };\n      }\n      case 'object': {\n        const properties: Record<string, JSONSchemaType> = {};\n        const required: string[] = [];\n\n        // Access shape directly from def\n        const shape = def.shape || {};\n        for (const [key, value] of Object.entries(shape)) {\n          // Handle both Zod v3 and v4 - in v4, each field has its own _def\n          const fieldDef =\n            (value as z.ZodTypeAny)._def ||\n            (value as z.ZodTypeAny & { def?: unknown }).def ||\n            value;\n          const fieldSchema = processZodType(fieldDef);\n          // Remove the __isOptional marker and use it to determine required fields\n          // const isOptional = fieldSchema.__isOptional;\n          delete fieldSchema.__isOptional;\n          properties[key] = fieldSchema;\n\n          // OpenAI requires all fields to be in the required array, even optional ones\n          // For optional fields, we'll handle it differently in the API\n          required.push(key);\n        }\n\n        return {\n          type: 'object',\n          properties,\n          required: required.length > 0 ? required : undefined,\n          additionalProperties: false,\n        };\n      }\n      case 'optional': {\n        // For OpenAI, we need to handle optional fields differently\n        // Return the inner type but mark that it's optional\n        const innerDef = def.innerType?._def || def.innerType?.def || def.innerType;\n        const innerType = innerDef ? processZodType(innerDef) : { type: 'string' };\n        return { ...innerType, __isOptional: true };\n      }\n      case 'enum':\n        return {\n          type: 'string',\n          enum: def.values,\n        };\n      case 'literal':\n        return {\n          type: typeof def.value,\n          const: def.value,\n        };\n      default:\n        // Fallback for unsupported types\n        return { type: 'string' };\n    }\n  }\n\n  return processZodType(zodType);\n}\n\nexport class OpenAIProvider implements TypedProvider<'openai'> {\n  readonly name = 'openai' as const;\n  readonly capabilities: ProviderCapabilities = {\n    streaming: true,\n    tools: true,\n    structuredOutput: true,\n    vision: true,\n    maxTokens: 128000,\n  };\n\n  private apiKey: string;\n  private baseURL = 'https://api.openai.com/v1';\n  private retryConfig?: RetryConfig;\n\n  constructor(apiKey: string, baseURL?: string, retryConfig?: RetryConfig) {\n    this.apiKey = apiKey;\n    if (baseURL) {\n      this.baseURL = baseURL.replace(/\\/$/, ''); // Remove trailing slash\n    }\n    this.retryConfig = retryConfig;\n  }\n\n  async chat<T = string>(\n    request: ProviderChatRequest<'openai'>,\n  ): Promise<ProviderChatResponse<'openai', T>> {\n    const makeRequest = async () => {\n      const openAIRequest = this.transformRequest(request);\n\n      const response = await fetch(`${this.baseURL}/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(openAIRequest),\n      });\n\n      if (!response) {\n        throw new LLMError(\n          'Network error: No response received',\n          undefined,\n          'openai',\n          request.model,\n        );\n      }\n\n      if (!response.ok) {\n        const error = (await response\n          .json()\n          .catch(() => ({ error: { message: response.statusText } }))) as {\n          error?: { message?: string };\n        };\n\n        // Extract retry-after header if present\n        const retryAfter = response.headers.get('Retry-After');\n        const errorMessage = `OpenAI API error (${response.status}): ${error.error?.message || 'Unknown error'}`;\n        const llmError = new LLMError(errorMessage, response.status, 'openai', request.model);\n        if (retryAfter) {\n          llmError.retryAfter = parseInt(retryAfter, 10);\n        }\n        throw llmError;\n      }\n\n      const data = (await response.json()) as OpenAIResponse;\n      return this.transformResponse<T>(data, request.schema);\n    };\n\n    // Use retry wrapper if config is provided\n    if (this.retryConfig) {\n      return retry(makeRequest, this.retryConfig);\n    }\n\n    return makeRequest();\n  }\n\n  async stream<T = string>(request: ProviderChatRequest<'openai'>): Promise<StreamingResponse<T>> {\n    const makeRequest = async (): Promise<Response> => {\n      const openAIRequest = this.transformRequest(request);\n      openAIRequest.stream = true;\n      openAIRequest.stream_options = { include_usage: true };\n\n      const response = await fetch(`${this.baseURL}/chat/completions`, {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${this.apiKey}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(openAIRequest),\n      });\n\n      if (!response.ok) {\n        const error = (await response\n          .json()\n          .catch(() => ({ error: { message: response.statusText } }))) as {\n          error?: { message?: string };\n        };\n\n        const retryAfter = response.headers.get('Retry-After');\n        const llmError = new LLMError(\n          error.error?.message || 'Unknown error',\n          response.status,\n          'openai',\n          request.model,\n        );\n        if (retryAfter) {\n          llmError.retryAfter = parseInt(retryAfter, 10);\n        }\n        throw llmError;\n      }\n\n      return response;\n    };\n\n    // Get response with retry support\n    const response = this.retryConfig\n      ? await retry(makeRequest, this.retryConfig)\n      : await makeRequest();\n\n    const reader = response.body!.getReader();\n    const decoder = new TextDecoder();\n    let buffer = '';\n    let content = '';\n    let usage: { prompt_tokens?: number; completion_tokens?: number; total_tokens?: number } = {};\n    let model = '';\n    let finishReason: 'stop' | 'length' | 'tool_calls' | 'content_filter' | undefined;\n    let toolCallArguments = '';\n    let currentToolCall: {\n      id: string;\n      type: 'function';\n      function: { name: string; arguments: string };\n    } | null = null;\n\n    const streamResponse = {\n      async *[Symbol.asyncIterator](): AsyncIterator<T> {\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) break;\n\n          buffer += decoder.decode(value, { stream: true });\n          const lines = buffer.split('\\n');\n          buffer = lines.pop() || '';\n\n          for (const line of lines) {\n            if (line.startsWith('data: ')) {\n              const data = line.slice(6);\n              if (data === '[DONE]') continue;\n\n              try {\n                const chunk: OpenAIStreamChunk = JSON.parse(data);\n                model = chunk.model;\n\n                if (chunk.choices[0]?.delta?.content) {\n                  const chunkContent = chunk.choices[0].delta.content;\n                  content += chunkContent;\n                  // For structured output, we can't yield partial JSON\n                  // So we only yield for string content\n                  if (!request.schema) {\n                    yield chunkContent as T;\n                  }\n                }\n\n                // Handle tool call streaming\n                if (chunk.choices[0]?.delta?.tool_calls) {\n                  for (const toolCallDelta of chunk.choices[0].delta.tool_calls) {\n                    if (toolCallDelta.id) {\n                      currentToolCall = {\n                        id: toolCallDelta.id!,\n                        type: 'function' as const,\n                        function: {\n                          name: toolCallDelta.function?.name || '',\n                          arguments: '',\n                        },\n                      };\n                      toolCallArguments = '';\n                    }\n                    if (toolCallDelta.function?.arguments) {\n                      toolCallArguments += toolCallDelta.function.arguments;\n                    }\n                  }\n                }\n\n                if (chunk.usage) {\n                  usage = {\n                    prompt_tokens: chunk.usage.prompt_tokens,\n                    completion_tokens: chunk.usage.completion_tokens,\n                    total_tokens: chunk.usage.total_tokens,\n                  };\n                }\n\n                if (chunk.choices[0]?.finish_reason) {\n                  finishReason = chunk.choices[0].finish_reason;\n                }\n              } catch {\n                // Ignore parsing errors\n              }\n            }\n          }\n        }\n      },\n\n      async complete(): Promise<ProviderChatResponse<'openai', T>> {\n        // Drain any remaining content\n        for await (const _chunk of streamResponse) {\n          // Just consume\n        }\n\n        let parsedContent: T;\n\n        // If we used schema-based tool calling, extract from tool call\n        if (\n          request.schema &&\n          toolCallArguments &&\n          currentToolCall?.function?.name === 'respond_with_structured_output'\n        ) {\n          try {\n            const parsed = JSON.parse(toolCallArguments);\n            parsedContent = request.schema.parse(parsed) as T;\n          } catch {\n            parsedContent = content as T;\n          }\n        } else if (request.schema && content) {\n          try {\n            const parsed = JSON.parse(content);\n            parsedContent = request.schema.parse(parsed) as T;\n          } catch {\n            parsedContent = content as T;\n          }\n        } else {\n          parsedContent = content as T;\n        }\n\n        return {\n          content: parsedContent,\n          usage: {\n            inputTokens: usage.prompt_tokens || 0,\n            outputTokens: usage.completion_tokens || 0,\n            totalTokens: usage.total_tokens || 0,\n          },\n          model,\n          finishReason,\n        };\n      },\n    };\n\n    return streamResponse;\n  }\n\n  supportsFeature(feature: string): boolean {\n    return (\n      feature in this.capabilities &&\n      (this.capabilities as unknown as Record<string, boolean>)[feature] === true\n    );\n  }\n\n  private transformRequest(request: ProviderChatRequest<'openai'>): OpenAIRequest {\n    const openAIRequest: OpenAIRequest = {\n      model: request.model || 'gpt-4o-mini', // Default fallback\n      messages: request.messages.map(this.transformMessage),\n      temperature: request.temperature,\n      max_tokens: request.maxTokens,\n    };\n\n    // Handle OpenAI-specific features\n    if (request.features) {\n      if (request.features.logprobs !== undefined) {\n        openAIRequest.logprobs = request.features.logprobs;\n      }\n      if (request.features.topLogprobs !== undefined) {\n        openAIRequest.top_logprobs = request.features.topLogprobs;\n      }\n      if (request.features.seed !== undefined) {\n        openAIRequest.seed = request.features.seed;\n      }\n      if (request.features.responseFormat !== undefined) {\n        openAIRequest.response_format = request.features.responseFormat as {\n          type: 'text' | 'json_object' | 'json_schema';\n          json_schema?: JSONSchemaType;\n        };\n      }\n    }\n\n    // Handle structured output via schema using forced tool calling\n    if (request.schema && !request.tools) {\n      // Create a hidden tool for structured output\n      const jsonSchema = zodToOpenAISchema(request.schema);\n      openAIRequest.tools = [\n        {\n          type: 'function' as const,\n          function: {\n            name: 'respond_with_structured_output',\n            description: 'Respond with structured data matching the required schema',\n            parameters: jsonSchema,\n            strict: true,\n          },\n        },\n      ];\n      // Force the model to use this tool\n      openAIRequest.tool_choice = 'required';\n    }\n\n    // Handle tools\n    if (request.tools) {\n      openAIRequest.tools = request.tools.map((tool) => ({\n        type: 'function' as const,\n        function: {\n          name: tool.name,\n          description: tool.description,\n          parameters: zodToOpenAISchema(tool.parameters),\n          strict: true,\n        },\n      }));\n    }\n\n    // Handle tool choice\n    if (request.toolChoice) {\n      switch (request.toolChoice) {\n        case 'required': {\n          openAIRequest.tool_choice = 'required';\n\n          break;\n        }\n        case 'none': {\n          openAIRequest.tool_choice = 'none';\n\n          break;\n        }\n        case 'auto': {\n          openAIRequest.tool_choice = 'auto';\n\n          break;\n        }\n        default:\n          if (typeof request.toolChoice === 'object' && 'name' in request.toolChoice) {\n            openAIRequest.tool_choice = {\n              type: 'function',\n              function: { name: request.toolChoice.name },\n            };\n          }\n      }\n    }\n\n    return openAIRequest;\n  }\n\n  private transformMessage(message: Message): OpenAIMessage {\n    if (typeof message.content === 'string') {\n      return {\n        role: message.role as 'system' | 'user' | 'assistant',\n        content: message.content,\n      };\n    }\n\n    // Handle multi-modal content\n    // For now, we'll just concatenate text content\n    // Full image support would require base64 encoding\n    const textContent = message.content\n      .filter((c) => c.type === 'text')\n      .map((c) => c.text)\n      .join('\\n');\n\n    return {\n      role: message.role as any,\n      content: textContent,\n    };\n  }\n\n  private transformResponse<T>(\n    response: OpenAIResponse,\n    schema?: z.ZodSchema,\n  ): ProviderChatResponse<'openai', T> {\n    const choice = response.choices[0];\n    if (!choice) {\n      throw new Error('No choice in response');\n    }\n    const message = choice.message;\n\n    let content: T;\n\n    // If we used schema-based tool calling, extract the structured data from tool call\n    if (schema && message.tool_calls && message.tool_calls.length > 0) {\n      const toolCall = message.tool_calls.find(\n        (tc) => tc.function.name === 'respond_with_structured_output',\n      );\n      if (toolCall) {\n        try {\n          const parsed = JSON.parse(toolCall.function.arguments);\n          content = schema.parse(parsed) as T;\n        } catch {\n          content = (message.content || '') as T;\n        }\n      } else {\n        content = (message.content || '') as T;\n      }\n    } else if (schema && message.content) {\n      try {\n        const parsed = JSON.parse(message.content);\n        content = schema.parse(parsed) as T;\n      } catch {\n        content = message.content as T;\n      }\n    } else {\n      content = (message.content || '') as T;\n    }\n\n    const result: ProviderChatResponse<'openai', T> = {\n      content,\n      usage: {\n        inputTokens: response.usage.prompt_tokens,\n        outputTokens: response.usage.completion_tokens,\n        totalTokens: response.usage.total_tokens,\n      },\n      model: response.model,\n      finishReason: choice.finish_reason,\n      systemFingerprint: response.system_fingerprint,\n    };\n\n    // Handle tool calls - but not if we used schema-based tool calling\n    if (message.tool_calls && !schema) {\n      result.toolCalls = message.tool_calls.map((tc) => ({\n        id: tc.id,\n        name: tc.function.name,\n        arguments: JSON.parse(tc.function.arguments),\n      }));\n    }\n\n    // Handle logprobs\n    if (choice.logprobs) {\n      result.logprobs = choice.logprobs.content.map((lp) => ({\n        token: lp.token,\n        logprob: lp.logprob,\n        topLogprobs: lp.top_logprobs,\n      }));\n    }\n\n    return result;\n  }\n\n  async listModels(): Promise<ModelInfo[]> {\n    const response = await fetch(`${this.baseURL}/models`, {\n      method: 'GET',\n      headers: {\n        Authorization: `Bearer ${this.apiKey}`,\n      },\n    });\n\n    if (!response.ok) {\n      const error = (await response\n        .json()\n        .catch(() => ({ error: { message: response.statusText } }))) as {\n        error?: { message?: string };\n      };\n      throw new LLMError(\n        `OpenAI API error (${response.status}): ${error.error?.message || 'Unknown error'}`,\n        response.status,\n        'openai',\n      );\n    }\n\n    const data = (await response.json()) as {\n      data: Array<{ id: string; created: number; owned_by: string }>;\n    };\n\n    return data.data.map((model) => ({\n      id: model.id,\n      name: model.id,\n      created: model.created,\n    }));\n  }\n}\n"]}